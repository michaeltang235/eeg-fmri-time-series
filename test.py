# -*- coding: utf-8 -*-
"""
Created on Thu Jul 22 12:14:07 2021

@author: siumichael.tang
"""

import os 
import re
import pandas as pd
import numpy as np
import nibabel as nib 

#import myfunction
from myfunction import get_path, sort_elect, mni2ijk, get_midpt_elect

#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
# BEGIN USER INPUT

# enter subject number (str)
subnum = '14';

# enter path to directory where all input files are located
directname = '/work/levan_lab/mtang/fmri_project/' + 'sub' + subnum
#directname = 'C:\\Users\\siumichael.tang\\Downloads\\fmri_project\\' + 'sub' + subnum

# format filenames of processed fmri images, explicit mask, electrode,
# motion parameters
filename_swraimg = '^swra.*\.nii$'   # processed func. images
filename_expmask = 'wEPI_bet_mask\.nii'   # explicit mask
filename_elect = subnum + '_.*Koordinaten.*\.xlsx'  # file containing mni coord. of all electrode pairs
filename_spikes = 'subject' + subnum + '_rates\.txt'   # file of spike rates
filename_motion = 'rp_.*\.txt'   # motion parameters generated by SPM in the realignment step

# enter path where ouput struct. is stored at
#fname_op = [directname, filesep, 'matrices' filesep 'reho_alff_spikes']   # direct. of output matrix
#eafilename_op = 'reho_alff_spikes.mat'   # filename of output file

# enter if output should be written to path (1 = yes, 0 = no)
op_results = 0

# END USER INPUT
#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
        
# use get_path function to obtain full path of input files
swra_file_path = get_path(directname, filename_swraimg)   # swra func. images
expmask_file_path = get_path(directname, filename_expmask)   # normalized mask images
elect_file_path = get_path(directname, filename_elect)   # file containing info. about electrodes coordinates
spikes_file_path = get_path(directname, filename_spikes)   # spike rates
motion_file_path = get_path(directname, filename_motion)   # motion parameters

# load processed images
run_ind = 0;

# create instance of processed image
swra_inst = nib.load(swra_file_path[run_ind])

# use get_fdata() method to obtain the actual image
# and use attribute, header, to obtain metadata (dict)
swra_img = swra_inst.get_fdata()   # actual image data
swra_header = swra_inst.header   # metadata about the image

# create instance of explicit mask, then get exp. mask image data
expmask = nib.load(expmask_file_path[0]).get_fdata()

# load electrode coordiantes from .xlsx file into dataframe, 
# selected only first 4 columns
elect_df = pd.read_excel(elect_file_path[0], usecols = list(range(5)))

# load spike rates from .txt file into dataframe, specify ' ' delimiter
spikes_df = pd.read_csv(spikes_file_path[0], sep = ' ')

# load motion parameters from .txt file into numpy array
motion_para = np.loadtxt(motion_file_path[run_ind])

#---------------------------------------------------------------------------
# Part (I): remove motion artifacts from processed image (entire brain)

# apply element-wise multiplciation btw. explicit mask and swra images
exp_swra_img = np.zeros(swra_img.shape)   # initialize array
for t in range(swra_img.shape[-1]):   # for swra img at every instant in time
    exp_swra_img[:, :, :, t] = expmask * swra_img[:, :, :, t]   
                
# call filter_motion.m to remove motion artifacts from image
#motion_filtered_img = filter_motion(motion_file_path, exp_swra_img);

# END Part (I): remove motion artifacts from processed images
#---------------------------------------------------------------------------



#---------------------------------------------------------------------------

# Part (IV): sort electrodes by their types

# use sort_elect to sort electrode array by their types
ele_sorted = sort_elect(elect_df)

# END PART (IV): sorte electrodes by their types
#---------------------------------------------------------------------------

# Part (V): find midpoint of each pair of electrode contacts in both mni
# and image space

midpt = get_midpt_elect(ele_sorted, swra_header)

# nested list midpt groups electrodes of same type into one element, 
# convert midpt to single layer list, with same column spec.
midpt_all = []   # initialize list
for i in range(len(midpt)):   # for every type of electrode
    for j in range(len(midpt[i])):   # for every channel in curr. type
        midpt_all.append(midpt[i][j])   # append info. to list
        
# END Part (V): find midpoint of each pair of electrode contacts in both mni
# and image space
#---------------------------------------------------------------------------

# Part (VI): get names and coordinates of channels with high spike rates
# during fmri scan

# format path to event location file
event_file_path = '/work/levan_lab/mtang/fmri_project/event_types_locations.txt'

# use pd.read_csv to get info in input txt file, 
# each row of the input file contains subject number, event marking, the 
# corresponding event type, and its location
ev_loc_df = pd.read_csv(event_file_path)   

# obtain series of booleans which consists of rows with subject number
# equal to the one that is being examined, then use the series to select 
# the rows interested
row_req = ev_loc_df.iloc[:, 0] == int(subnum)

# use row_req to select the portion of ev_loc_df wanted
ev_loc_df_selected = ev_loc_df.loc[row_req]

# get event types from 3rd col. and their locations from the rightmost col.
# remove white spaces in name tag, then convert them to list
ev_types = ev_loc_df_selected.iloc[:, 2].tolist()
ev_locations = ev_loc_df_selected.iloc[:, -1].str.strip().tolist()

# format channel names from ev_locations list, with the following format
# the i^th entry denotes the i^th type of channel
# the j^th element within i^th entry denotes the j^th channel name 
# e.g. ch_name[0][2] denotes the 2nd channel name under the 0^th type 
ch_name = []   # initialize list

# scan across every entry in ev_locations, search for alphabetic and numeric
# components of the name tag, then form number pairs and assemble channel names
# e.g. given LA1-5, further decompose the number sequence to intergal
# increments, so that we have LA1-2, LA2-3, LA3-4, LA4-5

for item in ev_locations:   # every element in ev_locations list
    ch_name_cur_type = []   # initialize list for current channel type
    ch_type = re.search('[a-zA-Z]+', item).group()   # get alphabetic compo.
    ele_con_num = re.findall('[0-9]+', item)   # get numeric compo.
    
    # if numeric compo. is not empty, form number sequence
    if ele_con_num:
        num_i = int(ele_con_num[0])   # initial number of sequence
        num_f = int(ele_con_num[1])   # final number of sequence
        num_s = num_i   # start number
        
        # as long as start number is less than final number
        while num_s < num_f:
            num_pair = np.linspace(num_s, num_s + 1, 2, dtype = int)   # form pair
            ch_name_str = ch_type + str(num_pair[0]) + '-' + ch_type \
                + str(num_pair[1])   # construct channel name
            ch_name_cur_type.append(ch_name_str)   # append name to curr. list
            num_s = num_s + 1   # increment start number by 1
        
        # after constructing names for every elements in the number sequence, 
        # append curr. list of channel names to ch_name
        ch_name.append(ch_name_cur_type)
        
    # if number is not recorded, leave it as it is
    else:
        ch_name.append([ch_type])
        
# nested list ch_name groups channels of same type into one element, 
# convert ch_name to single layer list, with same column spec.
ch_name_all = []   # initialize list
for i in range(len(ch_name)):   # for every type of channel
    for j in range(len(ch_name[i])):   # for every channel in curr. type
        ch_name_all.append(ch_name[i][j])   # append info. to list
        
# match channel name obtained to those in midpt_all nested list, if matched,
# assign all relevant info., including midpt corrdinates in mni and image
# spaces.
# if contact number is not given, match all available contacts for the channel
# type. i.e. if given LMT, instead of LMT1-2, match all available
# contacts in midpt_all, which gives LMT1-2, LMT2-3, and so on.
        
        




 
