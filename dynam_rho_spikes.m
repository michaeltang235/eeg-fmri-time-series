clear all 
close all

tic 
%---------------------------------------------------------------------------
%---------------------------------------------------------------------------
% BEGIN USER INPUT

% enter subject number (str)
subnum = '14';

% enter path to directory where all input files are located
directname = ['/work/levan_lab/mtang/fmri_project/', 'sub', subnum];
% directname = ['C:\Users\siumichael.tang\Downloads\fmri_project\', 'sub', subnum];

% format filenames of processed fmri images, explicit mask, electrode,
% motion parameters
filename_swraimg = ['swra*.nii'];   % processed func. images
filename_expmask = 'wEPI_bet_mask.nii';   % explicit mask
filename_elect =  [subnum, '_*Koordinaten*.xlsx'];   % file containing mni coord. of all electrode pairs
filename_spikes = ['subject', subnum, '_rates.txt'];   % file of spike rates
filename_motion = ['rp_*.txt'];   % motion parameters generated by SPM in the realignment step

% format path at which clinically determined reference channels located
clin_ref_ch_directname = '/work/levan_lab/mtang/fmri_project';   % directory where the file is
clin_ref_ch_filename = 'ref_channel_clin_det.txt';   % filename 

% enter path where ouput struct. is stored at
fname_op = [directname, filesep, 'matrices' filesep 'dynam_rho_spikes'];   % direct. of output matrix
filename_op = 'dynam_rho_spikes.mat';   % filename of output file

% enter if output should be written to path (1 = yes, 0 = no)
op_results = 1;

% END USER INPUT
%---------------------------------------------------------------------------
%---------------------------------------------------------------------------
%----------------------------------
% locate paths of func. images and their details 

% use get_path function to obtain full path of input files
[~, swra_file_path, ~] = get_path(directname, filename_swraimg);   % swra func. images
[~, expmask_file_path, ~] = get_path(directname, filename_expmask);   % normalized mask images
[~, elect_file_path, ~] = get_path(directname, filename_elect);   % file containing info. about electrodes coordinates
[~, spikes_file_path] = get_path(directname, filename_spikes);   % spike rates
[~, motion_file_path, ~] = get_path(directname, filename_motion);   % motion parameters

 % get full path of file of clinically determined reference channels
clin_ref_ch_file_path = fullfile(clin_ref_ch_directname, clin_ref_ch_filename);  

% createterms structure to store output data calcu. by function defined
% below
terms = struct;

% read input files and use get_rho_spikes function to get required data
for run_ind = 1:numel(swra_file_path)   % for each row in path of processed func. images
    
% run_ind = 1;
% read input files
swra_img = niftiread(swra_file_path{run_ind});   % swra func. images
swra_info = niftiinfo(swra_file_path{run_ind});   % info about this particular swra func. images
expmask = single(niftiread(expmask_file_path{:}));   % convert image data type to single
electar = readcell(elect_file_path{:});   % cell array containing info. about electrodes
spikesar = readcell(spikes_file_path{:});   % cell array containing info. about spike rates

% assemble input array of function, get_rho_spikes 
input_array = struct;   % initialize struct.
input_array.swra_img = swra_img;   % processed func. images
input_array.swra_info = swra_info;   % headers of processed func. images
input_array.expmask = expmask;   % explicit mask
input_array.electar = electar;   % array of electrode coordinates
input_array.spikesar = spikesar;   % array of spike rates
input_array.clin_ref_ch_file_path = clin_ref_ch_file_path;   % path of file of clin. det. channels
input_array.subnum = str2num(subnum);   % subject number in format of integer
input_array.motion_file_path = motion_file_path{run_ind};   % path of motion parameter file
% motion_file_path = motion_file_path{run_ind};

% get indices of current run number embedded in processed image filename
sind = regexp(lower(swra_file_path{run_ind}), 'run');   % start index
eind = regexp(lower(swra_file_path{run_ind}), '.nii');   % end index
sess_num = swra_file_path{run_ind}(sind+3:eind-1);   % get indices of run number

% create fieldname representing current session number
fieldname = sprintf('run%s', sess_num);

% store output calcu. under current fieldname of terms
terms.(fieldname) = get_dynam_rho_spikes(input_array);

% execute lines below if current field is not empty
if ~isempty(terms.(fieldname))
    
% access tables of current session created by function get_rho_spikes
table_rho_clin_ch = terms.(fieldname).table_rho_clin_ch;   % table of clinically det. channels

% format filenames and full paths of tables
filename_clin_table = ['sub', subnum, '_table_dynam_rho_clin_ch_run_', sess_num, '.csv'];
clin_table_path = fullfile(fname_op, filename_clin_table);   % path of table of clin. det. channels

%---------------------------------------------------------------------------
% output table and structure created in current session
if op_results == 1
    writetable(table_rho_clin_ch, clin_table_path);   % table of clin. det. ch.
    save(fullfile(fname_op, filename_op), 'terms');   % struct.
end
%---------------------------------------------------------------------------

end   % end if ~isempty(terms.(fieldname))

end   % end for run_ind = 1:numel(swra_file_path)

toc

%---------------------------------------------------------------------------
%---------------------------------------------------------------------------

% define function get_rho_spikes requiring an input array, which
% has the fields defined below,
% SWRA_IMG is the data of processed image file
% SWRA_INFO is the info (headers) associated with the processed image file
% EXPMASK is the explicit mask image
% ELECTAR is the array containing info. about all electrodes used,
% CLIN_REF_CH_FILE_PATH is the path of the file of clinically determined
% channels,
% SUBNUM is the subject number in integer form
% MOTION_FILE_PATH is the path of motion parameter file
% and outputs,
% OPSTRUCT, a structure that contains info. about coordinates of
% electrdoes, signals within 3X3X3 boxes centered at midpoint between
% electrode pairs, corr. coeff. btw. ref. and target channels, etc 
% see end of function for details of variables included in this struct.

function opstruct = get_dynam_rho_spikes(input_array)

% %---------------------------------------------------------------------------
% % Prelim: access variables defined in input array
swra_img = input_array.swra_img;   % processed func. images
swra_info = input_array.swra_info;   % headers of processed func. images
expmask = input_array.expmask;   % explicit mask
electar = input_array.electar;   % array of electrode coordinates
spikesar = input_array.spikesar;   % array of spike rates
clin_ref_ch_file_path = input_array.clin_ref_ch_file_path;   % path of clin. det. channels
subnum = input_array.subnum;   % subject number in format of integer
motion_file_path = input_array.motion_file_path;   % path of motion parameter file

% initialize output struct. as empty array
opstruct = [];

% % end Prelim: access variables defined in input array
% %---------------------------------------------------------------------------
% Part (I): sort electrodes by their types

% use sort_elect to sort electrode array by their types
ele_sorted = sort_elect(electar);

% END PART (I): sorte electrodes by their types
%---------------------------------------------------------------------------
% % Part (II): find midpoint of each pair of electrode contacts in both mni
% and image space

% use get_midpt_elect to locate midpoint of all electrode channels
% col. 1 = name of channel, 
% col. 2 = midpt in mni space, 
% col. 3 = midpt in image space
midpt = get_midpt_elect(ele_sorted, swra_info);

% END Part (II): find midpoint of each pair of electrode contacts in both mni
% and image space
%---------------------------------------------------------------------------

% Part (III): construct 3X3X3 boxes centered at midpoint of each electrode
% pair to store signals enclosed thereof

% assign essential variables for constructing the transfer function
% required for chebyshev filter
window_size = 60;   % in seconds
tr = 1.5;   % repetition time, in seconds

% initialize cell array named sig_box to store signals of voxels within
% 3X3X3 boxes, 
% col. 1: name tags of electrode pairs (channel)
% col. 2: motion-filtered signal within the 3X3X3 box of each channel
% col. 3: signal in col. 2 but decomposed into segments
% col. 4: noise-filtered (bandpass) signal of all segments in col. 3
% col. 5: averages of segments in col. 4
sig_box = {};

% use for loop to get signals within each box from processed (swra) func. images
for i = 1:numel(midpt)   % for each electrode type
    for j = 1:size(midpt{i}, 1)   % for each electrode pair under current type
        sig_box{i}{j, 1} = midpt{i}{j, 1};   % get name tag of electrode pair
        mxyz = midpt{i}{j, 3};   % get midpoint in image space
        
        % get signals from swra images, convert from int to double
        signal =  double(swra_img(mxyz(1)-1:mxyz(1)+1, mxyz(2)-1:mxyz(2)+1, ...
            mxyz(3)-1:mxyz(3)+1, :));  
        
        % filter motion artifacts from signal using filter_motion.m, then
        % assign that to col. 2 of current cell in sig_box
        signal_mo_filt = filter_motion(motion_file_path, signal);
        sig_box{i}{j, 2} = signal_mo_filt;

        % decompose motion-filtered signal into segments, then use
        % chebyshev filter to remove noise in each segment
        % accompolish this by calling seg_noise_filt.m
        [signal_seg, signal_noise_filt] = seg_noise_filt(signal_mo_filt, tr, window_size);
        
        % check if returned array of segmented siganl is empty, if so,
        % return control to line invoking this function,
        % get_dynam_rho_spikes, and output empty array opstruct.
        if isempty([signal_seg{:}])
            sprintf(['%s \n has length less than 10 mins', ...
                ', output empty array without creating table.'], swra_info.Filename)
            return
        end
        
        % assign outputs fom seg_noise_filt.m to sig_box array
        sig_box{i}{j, 3} = signal_seg;   % segmented signals
        sig_box{i}{j, 4} = signal_noise_filt;   % noise-filtered segments of signal
        
        % create regional mask from explicit mask using the coordinates of
        % the 3X3X3 box
        reg_mask = double(expmask(mxyz(1)-1:mxyz(1)+1, mxyz(2)-1:mxyz(2)+1, ...
            mxyz(3)-1:mxyz(3)+1));
        
        % calculate avg. of each segment formed, with mask applied
        % then assign avg. to sig_box array
        sig_seg_avg = segment_avg(signal_noise_filt, reg_mask);
        sig_box{i}{j, 5} = sig_seg_avg;   % avg. of signal segments
    end
end

% END Part (III): construct 3X3X3 boxes centered at midpoint of each electrode
% pair to store signal enclosed thereof
%---------------------------------------------------------------------------
% Part (IV): group signals of all channels in single layer

% group all electrode types in one single layer of cell array
% col. 1 = id assigned to electrode pair
% col. 2 = name tag of electrode pair
% col. 3 = motion-filtered signals within 3X3X3 box constructued
% col. 4 = signals in col. 3, but decomposed into segments
% col. 5 = signals in col. 4, but noise-filtered (bandpass filter)
% col. 6 = averages of sgements in col. 4
sig_box_all = {};   % initialize sig_box_all array
rownum = 1;   % initialize row number as 1 

for i = 1:numel(sig_box)   % for each electrode type in sig_box
    for j = 1:size(sig_box{i}, 1)   % for each pair of electrode contacts
        sig_box_all(rownum, 1) = {rownum};   % assign row number as id 
        sig_box_all(rownum, 2:2+size(sig_box{i}, 2)-1) = sig_box{i}(j, :);   % assign relevant info.
        rownum = rownum + 1;   % increment row number by 1
    end
end

% END Part (IV): group signals of all channels in single layer
%---------------------------------------------------------------------------
% Part (V): match channels in spike rates array with that of signal box

% use clean_match_spikes to get spikes struct.
spikes = clean_match_spikes(spikesar, sig_box, sig_box_all);

% get spike rates array in single layer with channels matched with sig_box_all
spikes_all = spikes.spikes_all;

% END Part (V): match channels in spike rates array with that of signal box
%---------------------------------------------------------------------------
% Part (VI): get correlation coefficient between electrode channels

% with ids assigned to pairs of electrode contacts, get correlation
% coefficients between each pair, store data in corr_array, with
% col. 1 = id of reference electrode pair, 
% col. 2 = id of target electrode pair, 
% col. 3 = name of reference electrode pair
% col. 4 = name of tagret electrode pair
% col. 5 = pearson's correlation coefficient between ref. and target pairs

% get total number of pairs of ele. contacts
num_contact_pair = size(sig_box_all, 1);

% initialize corr_array 
corr_array = cell(num_contact_pair^2, 5);
row = 1;   % initialize row number as 1

for i = 1:size(sig_box_all, 1)   % for each row in sig_box_all
    for j = 1:size(sig_box_all, 1)   % again, for each row in sig_box_all
        corr_array{row, 1} = sig_box_all{i, 1};   % id of ref. ele. pair
        corr_array{row, 2} = sig_box_all{j, 1};   % id of target ele. pair
        corr_array{row, 3} = sig_box_all{i, 2};   % name of ref. ele. pair
        corr_array{row, 4} = sig_box_all{j, 2};   % name of target ele. pair
        
        % initialize cell for storing corr. coeff. at all segments current
        % ref. and target channel pair
        corr_array{row, 5} = cell(1, length(sig_box_all{i, 6}));
        for seg_ind = 1:length(sig_box_all{i, 6})   % for each segment
            ref_sig = [sig_box_all{i, 6}{seg_ind}]';   % ref. signal segment
            tar_sig = [sig_box_all{j, 6}{seg_ind}]';   % target signal segment
            
            % corr. coef. btw. ref. and targ. sig.
            corr_array{row, 5}{seg_ind} = corr(ref_sig, tar_sig, 'Type', 'Pearson');  
        end
        
        row = row + 1;   % increment row number by 1        
    end
end

% END Part (VI): get correlation coefficient between electrode channels
%---------------------------------------------------------------------------
% Part (VII): grouped corr. coeff. and spike rates by ref. elect. channel

% exclude entries of corr. coeff. btw. 
% the same ref. and targ. electrode (e.g. {1, 1}, {2, 2}, ...)

% get list of ids and channel names
ids_all = cell2mat(sig_box_all(:, 1));

% sort corr. coeff. by electrode channels
cor_ref = {};   % initialize array
for ref_id = 1:length(ids_all)   % for each channel
    cor_ref{ref_id} = {};   % initialize cell for current channel
    for i = 1:size(corr_array, 1)   % for each row in corr_array
        % if id of ref. ch. (col. 1) agrees with current id, 
        % and if id of target ch. (col. 2) isn't the same as ref. ch.
        % assign relevant info. to cell of current ref. channel
        if (corr_array{i, 1} == ids_all(ref_id)) && (corr_array{i, 1} ~= corr_array{i, 2})
            cor_ref{ref_id} = [cor_ref{ref_id}; corr_array(i, :)];   % concatenate current cell
        end
    end
end

% get spike rates for all target elect. under each ref. elect. channel 
% in cor_ref,
% names of channels in both cor_ref and spikes_ref are in the same order
spikes_ref = {};    % initialize array
for ref_id = 1:length(ids_all)   % for each ref. elect. channel
    spikes_ref{ref_id} = {};   % initialize cell for current channel
    for i = 1:size(cor_ref{ref_id}, 1)   % for each row in current channel of cor_ref
        for j = 1:size(spikes_all, 1)   % for each row in spikes_all array
            % compare channel names in the two arrays, if name in current
            % row in cor_ref agrees with that in spikes_all, assign
            % relevant info. to current cell of spikes_ref by vertical
            % concatenation
            if strcmp(cor_ref{ref_id}{i, 4}, spikes_all{j, 2})
                spikes_ref{ref_id} = [spikes_ref{ref_id}; spikes_all(j, :)];  
                break;   % break loop if spike rates are found for current targ. ch.
            end
        end
    end
end

% Part (VII): grouped corr. coeff. and spike rates by ref. elect. channel
% %---------------------------------------------------------------------------
% Part (VIII): get standard deviation of corr. coeff. of all segments for
% every channel pair (dynamical func. connectivity)

std_ref = cell(size(cor_ref));   % initialize array

for ref_id = 1:numel(cor_ref)   % for every cell in cor_ref
    for i = 1:size(cor_ref{ref_id}, 1)   % for every channel pair
        std_ref{ref_id}(i, 1:4) = cor_ref{ref_id}(i, 1:4);   % assign ids and names
        % get standard dev. of all segments of current channel pair
        std_ref{ref_id}{i, 5} = std([cor_ref{ref_id}{i, 5}{:}]);   
    end
end

% Part (VIII): get standard deviation of corr. coeff. of all segments for
% every channel pair
% %---------------------------------------------------------------------------
% Part (IX): get correlations between dynam. func. conn. and spikes rates 
% of all ref. channels
 
% for each ref. channel, we have obtained the following
% (i) standard deviation of pearson's corr. coeff. in all segments for
% every channel pair
% (ii) spike rates of all target channels, 
% then get spearman's corr. coeff. (rho_cs_sp) between (i) and (ii)

% get corr. coeff. (spearman's) between corr coeff. btw. channels and spikes rates

% initialize arrays for storing spearman corr. coeff. and their p-values,
% with 1st layer denoting ref. ch. for which the var. interested are calcu.
rho_ss_sp = {};   % spearman corr., ''ss' stands for standard dev. and spike rates
pval_ss_sp = {};   % p-value of spearman corr.

% get spearman corr. coeff. and their p-values btw. (i) and (ii)
for ref_id = 1:numel(std_ref)   % for each ref. channel
    
    % get spearman corr. coeff. and their p-values btw. (i) and (ii) for
    % current ref. channel
    [rho_ss_sp{ref_id}, pval_ss_sp{ref_id}] = corr([std_ref{ref_id}{:, 5}]',...
            [spikes_ref{ref_id}{:, 3}]', 'Type', 'Spearman');
        
end   % end for ref_id = 1:numel(cor_ref)   % for each ref. channel

% END Part (IX): get correlations between func. conn. and spikes rates of
% all reference channels
%---------------------------------------------------------------------------
% Part (X): sort d.f.c. (standard dev.) and spike rates of ref. channels 
% into same and other types

% for each ref. channel, look for pairs with target
% channels belonging to types other than the ref. 

% get ids ov each electrode type
ids_type = cell(1, numel(sig_box));   % initialize cell array
row_i = 1;   % initialize row_id (initial row number)
for i = 1:numel(sig_box)   % for each type in sig_box
    rowspan = size(sig_box{i}, 1);   % get rowspan of current electrode type
    % get ids of current electrode type
    ids_type{i} = [sig_box_all{row_i:(row_i + rowspan - 1), 1}];   
    row_i = row_i + rowspan;   % adjust row_i for next electrode type
end

% initialize arrays for current ref. channel
spikes_ref_same_type = {};   % spike rates of pairs with targ. of same type
spikes_ref_other_type = {};   % spike rates of pairs with targ. of other types
std_ref_same_type = {};   % std of pairs with targ. of same type
std_ref_other_type = {};   % std of pairs with targ. of other types
    
% scan through each ref. channel, look for ids of target channels belonging
% to types other than the ref.
for ref_id = 1:numel(cor_ref)
    
    % initialize row numbers for arrays of same and other types
    row_ind_same_type = 1;   
    row_ind_other_type = 1;

    % get current electrode type of ref_id
    for i = 1:numel(ids_type)   % for each id type
        if ismember(ref_id, ids_type{i})   % if ref_id belongs to the type
            type_ind = i;   % get type of ref_id
        end
    end
    
    % for each pair under the current ref. channel
    for pair_ind = 1:size(std_ref{ref_id}, 1)
        
        % if id of targ. ch. belongs to the set of ids of current type
        % assign relevant info. to arrays of same type
        if ismember(std_ref{ref_id}{pair_ind, 2}, ids_type{type_ind})
            std_ref_same_type{ref_id}(row_ind_same_type, :) = std_ref{ref_id}(pair_ind, :);
            spikes_ref_same_type{ref_id}(row_ind_same_type, :) = spikes_ref{ref_id}(pair_ind, :);
            % increment row number by 1 for next targ. ch. identified as 
            % same type
            row_ind_same_type = row_ind_same_type + 1;   
        else
            % otherwise, assign info. to arrays of other types
            std_ref_other_type{ref_id}(row_ind_other_type, :) = std_ref{ref_id}(pair_ind, :);
            spikes_ref_other_type{ref_id}(row_ind_other_type, :) = spikes_ref{ref_id}(pair_ind, :);
            % increment row number by 1 for next targ. ch. identified as
            % other types
            row_ind_other_type = row_ind_other_type + 1;
        end
    end   % end for pair_ind = 1:size(cor_ref{ref_id}, 1)
    
end   % end for ref_id = 1:numel(cor_ref)

% Part (X): sort d.f.c. (standard dev.) and spike rates of ref. channels 
% into same and other types
%---------------------------------------------------------------------------
% Part (XI): get correlation btw. d.f.c. and spike rates for target channels
% of types different than the ref. 

% for each ref. channel, we have obtained
% (A) dynamic functional connectivity (d.f.c.) btw. the ref. and all
% targ. channels belonging to types other than the ref. and
% (B) the corresponding spike rates of targ. ch., 
% get spearman's corr. coeff. (rho_cs_sp_ot) btw. (A) and (B), '_ot' is
% added to denote 'other types'

% initialize arrays for storing spearman corr. coeff. and their p-values,
% with cells denoting ref. ch. for which (rho_sp) are calcu.
rho_ss_sp_ot = {};   % spearman corr. of ch. pairs of other types
pval_ss_sp_ot = {};   % p-value of spearman corr.

% get spearman corr. coeff. and their p-values btw. (i) and (ii)
for ref_id = 1:numel(std_ref_other_type)   % for each ref. channel
    
    [rho_ss_sp_ot{ref_id}, pval_ss_sp_ot{ref_id}] = corr([std_ref_other_type{ref_id}{:, 5}]',...
            [spikes_ref_other_type{ref_id}{:, 3}]', 'Type', 'Spearman');
        
end   % end for ref_id = 1:numel(cor_ref)   % for each ref. channel

% end Part (XI): get correlation btw. d.f.c. and spike rates for target channels
% of types different than the ref. 
%---------------------------------------------------------------------------
% Part (XII): identify clinically determined reference channels

% use get_clin_ref_ch to get clinically determined ref. channels and their ids 
ch_name_clinical = get_clin_ref_ch(subnum, clin_ref_ch_file_path, sig_box_all);

% Part (XII): identify clinically determined reference channels
% %---------------------------------------------------------------------------
% Part (XIII): generate tables listing all variables calculated

% initialize array storing var. calcu. for clinically determined ref. ch.
rho_clin_ch_array = {};   

% for each ref. ch., we computed pearson's corr. coeff. for each segment btw.
% the ref. ch. and every target channel. We then obtained (A) standard
% devation of all pearson's rho of all segments for every channel pair, 
% and (B) spike rates of all target channels w.r.t. the ref. After we calculated 
% (C) spearman's corr. coeff. btw. (A) and (B). 
% repeat the calcu. for cases when target ch. belong to types other than
% the ref. 

row_num = 1;   % initialize row number for assigning data to array
for i = 1:length(ch_name_clinical)   % for each type of clin. det. ch.
    for j = 1:size(ch_name_clinical{i}, 1)   % for each ch. in current type
        ref_id = ch_name_clinical{i}{j, 1};   % get id of ref. ch.
        rho_clin_ch_array{row_num, 1} = ref_id;   % assign id to array
        rho_clin_ch_array{row_num, 2} = ch_name_clinical{i}{j, 2};   % assign name to array
        rho_clin_ch_array{row_num, 3} = round(rho_ss_sp{ref_id}, 3);   % spearman's rho btw. (A) and (B)
        rho_clin_ch_array{row_num, 4} = round(pval_ss_sp{ref_id}, 3);   % p-val. of spearman's rho btw. (A) and (B)
        % for targ. ch. of types other than the ref., we have,
        rho_clin_ch_array{row_num, 5} = round(rho_ss_sp_ot{ref_id}, 3);   % other types, (C)
        rho_clin_ch_array{row_num, 6} = round(pval_ss_sp_ot{ref_id}, 3);   % p-val of other types, (C)
        rho_clin_ch_array{row_num, 7} = round(spikes_all{ref_id, 3}, 3);   % spike rates of ref. ch.
        row_num = row_num + 1;   % increment row number by 1
    end
end

% convert cell array to table and add table headers
table_rho_clin_ch = cell2table(rho_clin_ch_array, ...
    'VariableNames',{'id', 'channel name', 'rho_dynam', 'pval_rho_dynam', ...
    'rho_dynam_ot', 'pval_dynam_ot', 'spike rate [/min]'});
        
% Part (XIII): generate tables listing all variables calculated
% %---------------------------------------------------------------------------
% % Part (XIV): store variables in output structure

opstruct = struct;   % initialize struct.

opstruct.ele_sorted = ele_sorted;   % info. of electrode (sorted by name)
opstruct.midpt = midpt;   % coordinates of midpoint between each pair of electrode contacts 
opstruct.sig_box = sig_box;   % signals within 3X3X3 box centered at each midpoint
opstruct.sig_box_all = sig_box_all;   % signals within 3X3X3 box centered at each midpoint of all channels in single layer
opstruct.spikes_all = spikes_all;   % list of spike rates of all electrode pairs in single layer

opstruct.corr_array = corr_array;   % corr. coeff. (pearson's) btw. channels

opstruct.ids_all = ids_all;   % ids of all channels
opstruct.ids_type = ids_type;   % ids of all channels, sorted by types

% for every ref. channel, we identified spike rates of all target
% channels w.r.t. to the ref., we then computed pearson's corr. coeff.
% btw. each segment for every pair. After, we obtained standard
% deviation of all pearson's corr. coeff. for each channel pair
opstruct.cor_ref = cor_ref;   % corr. coeff. (pearson's) btw. ref. (1st layer) and targ. (2nd layer) channels
opstruct.std_ref = std_ref;   % standard dev. of pearson's rho of all segements for every channel pair
opstruct.spikes_ref = spikes_ref;   % spike rates of targ. (2nd layer) channels

% for each ref. channel, with dynam. func. conn. (standard dev.) (A) and
% spike rates (B) btw. the ref. ch. and every target ch. obtained,
% we calculated spearman's corr. coeff. (rho_sp) btw. (A) and (B), 
% and their p-values
opstruct.rho_ss_sp = rho_ss_sp;   % rho_sp btw. (A) and (B)
opstruct.pval_ss_sp = pval_ss_sp;   % p-val. of rho_sp btw. (A) and (B)

% for spearman's corr. coeff. btw. (A) and (B), with target channels
% belonging to types other than the ref. 
opstruct.rho_ss_sp_ot = rho_ss_sp_ot;   % other types, rho_sp btw. (A) and (B) 
opstruct.pval_ss_sp_ot = pval_ss_sp_ot;   % other types, p-values.

opstruct.ch_name_clinical = ch_name_clinical;   % clin. det. ref. ch.
opstruct.table_rho_clin_ch = table_rho_clin_ch;   % table

% Part (XIV): store variables in output structure
%---------------------------------------------------------------------------

end   % end function opstruct = get_dynam_rho_spikes(input_array)
