clear all
close all

% Oct. 12, 2022: updated list of "ied onset" and "ied propagating" channels
% is used and can be found here:
% /work/levan_lab/mtang/fmri_project/ied_onset_ied_propa_ch.txt

%---------------------------------------------------------------------------
%---------------------------------------------------------------------------
% BEGIN USER INPUT

tic 

% enter path to directory where info. of all subjects are stored
% subnum_dir = 'C:\Users\siumichael.tang\Downloads\fmri_project'; 
subnum_dir = '/work/levan_lab/mtang/fmri_project/';

% enter if output should be written to path (1 = yes, 0 = no)
op_results = 1;

% END USER INPUT
%---------------------------------------------------------------------------
%---------------------------------------------------------------------------

%---------------------------------------------------------------------------
% (A): identify list of subject numbers with path input

% use dir to get a struct for all folders/files found in subject direct
folder_list = dir(subnum_dir);

% access name of every folder/file identified, then search for pattern of
% 'sub\d*' in it, if matched, extract the subject number
sub_list = [];   % initialize array for storing subject numbers
for item = 1:numel(folder_list)   % every item in folders/files found
    
    % search filename with matching pattern 'sub\d*', then use strrep to
    % replace 'sub' by '' to obtain subject number
    matched_str = regexp(folder_list(item).name, '^sub\d*$', 'match');
    matched_sub_num = strrep(matched_str, 'sub', '');
    
    % if pattern is found, add subject number to sub_list
    if ~isempty(matched_str)
        sub_list = [sub_list matched_sub_num];
    end
end

% END (A): identify list of subject numbers with path input
%---------------------------------------------------------------------------


% (B): compute (i) ReHo and (ii) IED rate measured during long-term monitoring,
% and (iii) IED rate measured over entire scan, and get spearman's rho btw.
% (i) and (ii), and (i) and (iii), for every session of each subject

% initialize structure, grand, to store relevant info. of every subject
grand = struct;

% loop through each subject number identified and conduct analysis
% for item = 2:2
for item = 1:numel(sub_list)

% get current subject number
subnum = sub_list{item};

% sprintf(['begin working on sub', subnum])

%---------------------------------------------------------------------------
% (B1): format paths of required files for current subject

% enter path to directory where all input files are located
directname = [subnum_dir, filesep, 'sub', subnum];
% directname = ['C:\Users\siumichael.tang\Downloads\fmri_project\', 'sub', subnum];

% format filenames of processed fmri images, explicit mask, electrode,
% motion parameters
filename_swraimg = ['swra*.nii'];   % processed func. images
filename_expmask = 'wEPI_bet_mask.nii';   % explicit mask
filename_elect =  [subnum, '_*Koordinaten*.xlsx'];   % file containing mni coord. of all electrode pairs
filename_event_onset = ['find_onset_times_sub', subnum, '.mat'];   % file of event onsets   
filename_motion = ['rp_*.txt'];   % motion parameters generated by SPM in the realignment step

% enter path where ouput struct. is stored at
fname_op = [subnum_dir, filesep, 'matrices' filesep 'static_analysis_fc'];   % direct. of output matrix
filename_op = 'static_analysis_fc.mat';   % filename of output file

% END (B1): format paths of required files for current subject
%---------------------------------------------------------------------------
% (B2): obtain full paths of required files for current subject

% use get_path function to obtain full path of input files
[~, swra_file_path, ~] = get_path(directname, filename_swraimg);   % swra func. images
[~, expmask_file_path, ~] = get_path(directname, filename_expmask);   % normalized mask images
[~, elect_file_path, ~] = get_path(directname, filename_elect);   % file containing info. about electrodes coordinates
[~, event_onsets_file_path, ~] = get_path([directname, filesep, 'matrices'], filename_event_onset);   % file of event onsets
[~, motion_file_path, ~] = get_path(directname, filename_motion);   % motion parameters

% END (B2): obtain full paths of required files for current subject
%---------------------------------------------------------------------------
% (B3): conduct analysis for current subject

% createterms structure to store info. of every session of each subject
terms = [];

% loop through every session of current subject and calculate relevant
% quantities

% for run_ind = 1:1   % for every session
for run_ind = 1:numel(swra_file_path)   % for every session

    %---------------------------------------------------------------------------
    
    % PART (0): read input files for current session of current subject 
   
    swra_img = niftiread(swra_file_path{run_ind});   % swra func. images
    swra_info = niftiinfo(swra_file_path{run_ind});   % info about this particular swra func. images
    expmask = single(niftiread(expmask_file_path{:}));   % convert image data type to single
    electar = readcell(elect_file_path{:});   % cell array containing info. about electrodes
    event_onsets_st = load(event_onsets_file_path{:});   % struct. containing event onsets
   
    % access info for current session
    field_runs = fieldnames(event_onsets_st.terms);   % fieldname under event onsets structure
    event_onsets_curr_sess = event_onsets_st.terms.(field_runs{run_ind});   % array of event onsets for current session
    
    motion_file_path_curr_sess = motion_file_path{run_ind};   % motion parameter path for current session
    
    % END PART (0): read input files for current session of current subject 
    %---------------------------------------------------------------------------
    % Part (I): remove motion artifacts from processed images

    % convert explicit mask and processed image to double, 
    % apply element-wise multiplciation
    exp_swra_img = double(expmask).*double(swra_img);
                
    % call filter_motion.m to remove motion artifacts from image
    motion_filtered_img = filter_motion(motion_file_path_curr_sess, exp_swra_img);

    % END Part (I): remove motion artifacts from processed images
    %---------------------------------------------------------------------------
    % Part (II): sort electrodes by their types

    % use sort_elect to sort electrode array by their types
    ele_sorted = sort_elect(electar);

    % END PART (II): sorte electrodes by their types
    %---------------------------------------------------------------------------
    % % Part (III): find midpoint of each pair of electrode contacts in both mni
    % and image space

    % use get_midpt_elect to locate midpoint of all electrode channels
    % col. 1 = name of channel, 
    % col. 2 = midpt in mni space, 
    % col. 3 = midpt in image space
    midpt = get_midpt_elect(ele_sorted, swra_info);

    % cell array midpt groups electrodes of same type into one cell, 
    % convert midpt to single layer cell array, with same column spec. 
    midpt_all = {};   % initialize cell array
    rownum = 1;   % initiaize row number

    for i = 1:numel(midpt)   % for each cell (each electrode type)
        for j = 1:size(midpt{i}, 1)   % for each row in current cell
            midpt_all(rownum, :) = midpt{i}(j, :);   % assign all col. to array
            rownum = rownum + 1;   % increase row number by 1 for next row read
        end
    end

    % END Part (III): find midpoint of each pair of electrode contacts in both mni
    % and image space
    %---------------------------------------------------------------------------

    % Part (IV): remove noise and get avg. siganl of every channel

    % get basic info. about processed image
    tr = swra_info.PixelDimensions(4);   % repetition time, in seconds
    fs = 1/tr; % sampling frequency, in Hz

    % % initialize array, sig_box_all, for storing the following for every channel matched
    % % 1st column lists the names of channels,
    % % 2nd column lists avg. signal in 3X3X3 box of every channel
    sig_box_all = {};

    for item = 1:size(midpt_all, 1)
    
        sig_box_all(item, 1) = midpt_all(item, 1);   % channel name
    
        % get coordinates of midpt of channel in image space
        mxyz = midpt_all{item, end};

        % define ROI as 3X3X3 box centered at midpitn of a channel, 
        % get signals within each ROI from motion-filtered images
        signal =  double(motion_filtered_img(mxyz(1)-1:mxyz(1)+1, mxyz(2)-1:mxyz(2)+1, ...
            mxyz(3)-1:mxyz(3)+1, :));

        % use Chebyshev Type 1 bandpass filter to allow freq. compo. btw. 
        % [0.01 and 0.1] Hz to pass through, use cheby1 to get 
        % transfer function coefficients (normalized freqs. are used)
        [b,a] = cheby1(2,0.5,[0.01 0.1]/(fs/2));

        % apply bandpass filter (Chebyshev filter) to remove low-freq. drift 
        % and noises from signal
        signal_noise_filt = signal;   % initialize array
        for x_vox = 1:size(signal, 1)   % for each voxel in x-dir.
            for y_vox = 1:size(signal, 2)   % for each voxel in y-dir.
                for z_vox = 1:size(signal, 3)   % for each voxel in z-dir.
                    % extract signal at voxel interested, squeeze the
                    % array to remove dim. of length 1, then use Chebyshev
                    % filter to remove noises
                    signal_noise_filt(x_vox, y_vox, z_vox, :) = ...
                            filtfilt(b, a, squeeze(signal(x_vox, y_vox, z_vox, :)));
                end
            end
        end

        % create regional mask from explicit mask using the coordinates of
        % the 3X3X3 box
        reg_mask = double(expmask(mxyz(1)-1:mxyz(1)+1, mxyz(2)-1:mxyz(2)+1, ...
            mxyz(3)-1:mxyz(3)+1));
    
        % get number of non-zero entries in regional mask  
        num_nonzero = nnz(reg_mask);   
    
        % get avg. signal within the current box (roi)
        avg_signal = zeros(1, size(signal_noise_filt, 4));   % initialize avg. signal array
        for t = 1:size(signal_noise_filt, 4)   % for each time step
            % get sum of singals in box at current time, then get average
            % signal by dividing the sum by number of non-zero entries in
            % in the regional mask
            % could have used mean(nonzeros), but this method is adopted just 
            % in case if the signal is zero but the mask isn't at a voxel
            avg_signal(t) = sum(sum(sum((signal_noise_filt(:, :, :, t)))))/num_nonzero;
        end

        % assign avg singal of each channel to col. 2 of sig_box
        sig_box_all{item, 2} = avg_signal;

    end   % end for item = 1:size(midpt_all, 1)

    % END Part (IV): remove noise and get avg. siganl of every channel
    %---------------------------------------------------------------------------

    % Part (V): get names and event types of ied onset and ied
    % propagation, and no-ied channels

    % use get_ied_onset_ied_propa to get array containing names of 
    % ied onset and ied propagation channels, as well as their event types
    % ch_list_onset = ied onset channels
    % ch_list_propa = ied propagation channels
    % ch_list_all = ch_list_onset + ch_list_propa, any channels with ieds
    % registered during fmri scan
    [ch_list_onset, ch_list_propa, ch_list_all] = get_ied_onset_ied_propa_ch(subnum);

    % create array to store combinatons of channels used
    ch_pair_used = {};

    % form channel pairs in the following order,
    % (1) selecting pairs of ied onset - ied onset channels, both of 
    % same ied type, then
    % (2) selecting pairs of ied onset - ied propagation chanenls, both of
    % same ied type
    % (3) selecting pairs of ied onset - ied onset channels, of
    % different event types
    % (4) selecting pairs of ied onset - propagation channels, of
    % different event types
    % (5) selecting pairs of ied onset - no ied channels
    % note: after a pair is selected, their names are removed from the
    % lists of channels available to choose from. i.e. no duplicate pairs

    % flow-chart of picking channel pairs is as follow, 
    % choose event type, then choose reference channel name, 
    % in the same array, choose target channel name, check if they both
    % have the same event type, if their names are the same, and if the
    % pair has been used before.

    % initialize array, ch_pair, with format given below
    % 1st col. = subject number
    % 2nd col. = ied type of reference channel (event type)
    % 3rd col. = name of ref. channel
    % 4th col. = channel type (ied onset, propagation, or no ied)
    % 5th col. = ied type of target channel
    % 6th col. = name of target channel
    % 7th col. = channel type (ied onset, propagation, or no ied)

    % format channel pairs (ied onset - ied onset, both of same ied type)
    ch_pair = {};
    row_num = 1;
    for i = 1:size(ch_list_onset, 1)
        ref_ev_type = ch_list_onset{i, 2};
        ref_name = ch_list_onset{i, 3};
        for j = 1:size(ch_list_onset, 1)
            targ_ev_type = ch_list_onset{j, 2};
            targ_name = ch_list_onset{j, 3};
            if isequal(ref_ev_type, targ_ev_type) && ~isequal(ref_name, targ_name) ...
                    && isequal(check_pair(ref_name, targ_name, ch_pair_used), 0)
                ch_pair{row_num, 1} = ch_list_onset{i, 1};
                ch_pair{row_num, 2} = ch_list_onset{i, 2};
                ch_pair{row_num, 3} = ch_list_onset{i, 3};
                ch_pair{row_num, 4} = 'IED onset';
                ch_pair{row_num, 5} = ch_list_onset{j, 2};
                ch_pair{row_num, 6} = ch_list_onset{j, 3};
                ch_pair{row_num, 7} = 'IED onset';
                row_num = row_num + 1;

                % update channel pair used 
                ch_pair_used = [ch_pair_used; {ref_name targ_name}];
            end
        end
    end

    % format channel pairs (ied onset - ied propagation, both of same ied type)
    for i = 1:size(ch_list_onset, 1)
        ref_ev_type = ch_list_onset{i, 2};
        ref_name = ch_list_onset{i, 3};
        for j = 1:size(ch_list_propa, 1)
            targ_ev_type = ch_list_propa{j, 2};
            targ_name = ch_list_propa{j, 3};
            if isequal(ref_ev_type, targ_ev_type) && ~isequal(ref_name, targ_name) ...
                    && isequal(check_pair(ref_name, targ_name, ch_pair_used), 0)
                ch_pair{row_num, 1} = ch_list_onset{i, 1};
                ch_pair{row_num, 2} = ch_list_onset{i, 2};
                ch_pair{row_num, 3} = ch_list_onset{i, 3};
                ch_pair{row_num, 4} = 'IED onset';
                ch_pair{row_num, 5} = ch_list_propa{j, 2};
                ch_pair{row_num, 6} = ch_list_propa{j, 3};
                ch_pair{row_num, 7} = 'IED propa';
                row_num = row_num + 1;

                % update channel pair used 
                ch_pair_used = [ch_pair_used; {ref_name targ_name}];
            end
        end
    end   

    % format channel pairs (ied onset - ied onset, of different ied type)
    for i = 1:size(ch_list_onset, 1)
        ref_ev_type = ch_list_onset{i, 2};
        ref_name = ch_list_onset{i, 3};
        for j = 1:size(ch_list_onset, 1)
            targ_ev_type = ch_list_onset{j, 2};
            targ_name = ch_list_onset{j, 3};
            if ~isequal(ref_ev_type, targ_ev_type) && ~isequal(ref_name, targ_name) ...
                    && isequal(check_pair(ref_name, targ_name, ch_pair_used), 0)
                ch_pair{row_num, 1} = ch_list_onset{i, 1};
                ch_pair{row_num, 2} = ch_list_onset{i, 2};
                ch_pair{row_num, 3} = ch_list_onset{i, 3};
                ch_pair{row_num, 4} = 'IED onset';
                ch_pair{row_num, 5} = ch_list_onset{j, 2};
                ch_pair{row_num, 6} = ch_list_onset{j, 3};
                ch_pair{row_num, 7} = 'IED onset';
                row_num = row_num + 1;

                % update channel pair used 
                ch_pair_used = [ch_pair_used; {ref_name targ_name}];
            end
        end
    end

    % format channel pairs (ied onset - ied propa, of different ied type)
    for i = 1:size(ch_list_onset, 1)
        ref_ev_type = ch_list_onset{i, 2};
        ref_name = ch_list_onset{i, 3};
        for j = 1:size(ch_list_propa, 1)
            targ_ev_type = ch_list_propa{j, 2};
            targ_name = ch_list_propa{j, 3};
            if ~isequal(ref_ev_type, targ_ev_type) && ~isequal(ref_name, targ_name) ...
                    && isequal(check_pair(ref_name, targ_name, ch_pair_used), 0)
                ch_pair{row_num, 1} = ch_list_onset{i, 1};
                ch_pair{row_num, 2} = ch_list_onset{i, 2};
                ch_pair{row_num, 3} = ch_list_onset{i, 3};
                ch_pair{row_num, 4} = 'IED onset';
                ch_pair{row_num, 5} = ch_list_propa{j, 2};
                ch_pair{row_num, 6} = ch_list_propa{j, 3};
                ch_pair{row_num, 7} = 'IED propa';
                row_num = row_num + 1;

                % update channel pair used 
                ch_pair_used = [ch_pair_used; {ref_name targ_name}];
            end
        end
    end

    % format channel pairs (ied onset - no ied, w.r.t. each ied onset)
    for i = 1:size(ch_list_onset, 1)
        ref_ev_type = ch_list_onset{i, 2};
        ref_name = ch_list_onset{i, 3};
        for j = 1:size(sig_box_all, 1)
            targ_ev_type = ref_ev_type;
            targ_name = sig_box_all{j, 1};
            if isempty(intersect(ch_list_all(:, end), targ_name)) ...
                    && isequal(check_pair(ref_name, targ_name, ch_pair_used), 0)
                ch_pair{row_num, 1} = ch_list_onset{i, 1};
                ch_pair{row_num, 2} = ch_list_onset{i, 2};
                ch_pair{row_num, 3} = ch_list_onset{i, 3};
                ch_pair{row_num, 4} = 'IED onset';
                ch_pair{row_num, 5} = 'NA';
                ch_pair{row_num, 6} = sig_box_all{j, 1};
                ch_pair{row_num, 7} = 'no IED';
                row_num = row_num + 1;

                % update channel pair used 
                ch_pair_used = [ch_pair_used; {ref_name targ_name}];
            end
        end
    end

    % END Part (V): assign avg. signal to IED onset, IED propagation, and
    % no IED channels
    %---------------------------------------------------------------------------

    % Part (VI): compute functional connectivity btw. every channel pair
   
    % get number of columns established in ch_pair array
    ncol = size(ch_pair, 2);
    
    % get fc for each channel pair, format of array is given below
    % 1st col. = subject number
    % 2nd col. = ied type of reference channel (event type)
    % 3rd col. = name of ref. channel
    % 4th col. = channel type (ied onset, propagation, or no ied)
    % 5th col. = ied type of target channel
    % 6th col. = name of target channel
    % 7th col. = channel type (ied onset, propagation, or no ied)
    % 8th col. = functional connectivity
   
    fc_ar = {};   % initialize array 
    row_num = 1;   % initialize row number
    for i = 1:size(ch_pair, 1)   % for each row in ch_pair array
        ref_name = ch_pair{i, 3};   % select ref. ch. name
        targ_name = ch_pair{i, 6};   % select target ch. name

        % get indices of ref. and target channels in sig_box_all
        [~, ind_ref_name, ~] = intersect(sig_box_all(:, 1), ref_name);
        [~, ind_targ_name, ~] = intersect(sig_box_all(:, 1), targ_name);

        % if indices aren't empty, compute pearson's corr. coeff.
        if ~isempty(ind_ref_name) && ~isempty(ind_targ_name)
            fc = corr(sig_box_all{ind_ref_name, end}', sig_box_all{ind_targ_name, end}', 'Type', 'Pearson');
            fc_ar(row_num, 1:ncol) = ch_pair(i, :);
            fc_ar{row_num, ncol+1} = fc;
            row_num = row_num + 1;   % increment row number by 1 for next ch. pair
        end
    end

    % END Part (VI): compute functional connectivity btw. every channel pair
    %---------------------------------------------------------------------------

    % Part (VI): store quantities calculated in current run to struct

    % get indices of current run number embedded in processed image filename
    sind = regexp(lower(swra_file_path{run_ind}), 'run');   % start index
    eind = regexp(lower(swra_file_path{run_ind}), '.nii');   % end index
    sess_num = swra_file_path{run_ind}(sind+3:eind-1);   % get indices of run number

    % create fieldname representing current session number
    fieldname = sprintf('run%s', sess_num);

    % assign variables of interest to current fieldname
    terms.(fieldname).sig_box_all = sig_box_all;   % avg. signal of each channel
    terms.(fieldname).ch_list_onset = ch_list_onset;   % list of ied onset channels 
    terms.(fieldname).ch_list_propa = ch_list_propa;   % list of ied propagation channels 
    terms.(fieldname).fc_ar = fc_ar;   % fc array, see above for details

    % print message to console 
    sprintf('done working on run %d of subject %s', run_ind, subnum)

    % END Part (VI): store quantities calculated in current run to struct
    %---------------------------------------------------------------------------

end   % end for run_ind = 1:numel(swra_file_path)   % for every session

% format fieldname for current subject number
g_fdname = ['sub', subnum];   % format fieldname for current subject number
grand.(g_fdname) = terms;   % update grand, struct, with info of curr. sub.

% output structure created 
if op_results == 1
    save(fullfile(fname_op, filename_op), 'grand');
end

end   % end for item = 1:numel(sub_list)

% END (B3): conduct analysis for current subject
%---------------------------------------------------------------------------

toc



%--------------------------------------
% USER DEFINED FUNCTION:

% This function intakes names of channels and ch_chair_used array, and
% returns if the pair of channels is included in ch_chair_used array
function used_ch = check_pair(name1, name2, ch_pair_used)
used_ch = 0;
for i = 1:size(ch_pair_used)
    if ~isempty(intersect(ch_pair_used(i, :), name1)) && ~isempty(intersect(ch_pair_used(i, :), name2))
        used_ch = 1;
        return
    end
end
end

%--------------------------------------