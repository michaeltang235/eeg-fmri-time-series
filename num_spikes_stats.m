clear all 
close all

% This script calculates (i) number of spikes in every segment within
% time series, (ii) mean, and (iii) standard deviation of (i)

tic 
%---------------------------------------------------------------------------
%---------------------------------------------------------------------------
% BEGIN USER INPUT

% enter subject number (str)
subnum = '14';

% enter path to directory where all input files are located
directname = ['/work/levan_lab/mtang/fmri_project/', 'sub', subnum];
% directname = ['C:\Users\siumichael.tang\Downloads\fmri_project\', 'sub', subnum];

% format filenames of processed fmri images, explicit mask, electrode,
% motion parameters
filename_swraimg = ['swra*.nii'];   % processed func. images
% filename_expmask = 'wEPI_bet_mask.nii';   % explicit mask
% filename_elect =  [subnum, '_*Koordinaten*.xlsx'];   % file containing mni coord. of all electrode pairs
filename_event_onset = ['onset_times_events_sub', subnum, '.mat'];   % file of event onsets   
% filename_motion = ['rp_*.txt'];   % motion parameters generated by SPM in the realignment step

% enter path where ouput struct. is stored at
fname_op = [directname, filesep, 'matrices' filesep 'num_spikes_stats'];   % direct. of output matrix
filename_op = 'num_spikes_stats.mat';   % filename of output file

% enter window size in seconds (must be divisible by tr, i.e. 1.5 s)
window_size = 120;

% enter if output should be written to path (1 = yes, 0 = no)
op_results = 1;

% END USER INPUT
%---------------------------------------------------------------------------
%---------------------------------------------------------------------------

% locate paths of func. images and their details 

% use get_path function to obtain full path of input files
[~, swra_file_path, ~] = get_path(directname, filename_swraimg);   % swra func. images
[~, event_onsets_file_path, ~] = get_path([directname, filesep, 'matrices'], filename_event_onset);   % file of event onsets

% createterms structure to store output data calcu. by function defined
% below
terms = struct;

% read input files and use get_rho_spikes function to get required data
for run_ind = 1:numel(swra_file_path)   % for each row in path of processed func. images

swra_info = niftiinfo(swra_file_path{run_ind});   % info about this particular swra func. images
event_onsets = load(event_onsets_file_path{:});   % struct. containing event onsets

% assemble input array of function, get_rho_spikes 
input_array = struct;   % initialize struct.
input_array.swra_info = swra_info;   % headers of processed func. images

field_runs = fieldnames(event_onsets.terms);
input_array.event_onsets = event_onsets.terms.(field_runs{run_ind});   % array of event onsets
% input_array.motion_file_path = motion_file_path{run_ind};   % path of motion parameter file

input_array.subnum = subnum;   % subject number of interest
input_array.window_size = window_size;   % window size entered

% get indices of current run number embedded in processed image filename
sind = regexp(lower(swra_file_path{run_ind}), 'run');   % start index
eind = regexp(lower(swra_file_path{run_ind}), '.nii');   % end index
sess_num = swra_file_path{run_ind}(sind+3:eind-1);   % get indices of run number

% create fieldname representing current session number
fieldname = sprintf('run%s_winsize_%s', sess_num, num2str(window_size));

% store output calcu. under current fieldname of terms
terms.(fieldname) = get_spikes_stats(input_array);

% execute lines below if current field is not empty
if ~isempty(terms.(fieldname))
    
% % access tables of current session created by function
% % get_mnalff_num_spikes
table_spikes_stats = terms.(fieldname).table_spikes_stats;

% format filenames and full paths of tables
filename_table = ['sub', subnum, '_table_spikes_stats_run', sess_num, ...
    '_winsize_', num2str(window_size), '.csv'];
table_path = fullfile(fname_op, filename_table);   % path of table of clin. det. channels

%---------------------------------------------------------------------------
% output table and structure created in current session
if op_results == 1
    writetable(table_spikes_stats, table_path);   % table of clin. det. ch.
    save(fullfile(fname_op, filename_op), 'terms');   % struct.
%     save(fullfile(fname_op, filename_op), 'terms', '-v7.3');
end
%---------------------------------------------------------------------------

end   % end if ~isempty(terms.(fieldname))

end   % end for run_ind = 1:numel(swra_file_path)

toc

%---------------------------------------------------------------------------
% (A): EXECUTE THE FOLLOWING AFTER CALLING FUNCTION ON EACH RUN

% access fieldnames of struct. terms
fds = fieldnames(terms);

% get non-empty fieldnames
fd_ind = [];   % initialize array for storing indices of non-empty fields
for sess_ind = 1:length(fds)   % for each field
    if ~isempty(terms.(fds{sess_ind}))   % check if field is empty
        fd_ind = [fd_ind sess_ind];   % if not, append index to array
    end
end
fdnames = fds(fd_ind);   % access all non-empty fields using indices acquired

% execute the lines below if there exists at least one non-empty field
if length(fdnames) >= 1

%--------------------------
% (A1): combine number of spikes from all runs together

% transform array to single layer, concatenating num_spikes arrays 
% from diff. runs together
num_spikes_all = {};   % initialize array
for sess_ind = 1:length(fdnames)   % for each session
    % get num_spikes array for current session;   
    num_spikes_cur = terms.(fdnames{sess_ind}).num_spikes;
    % concatenate arrays vertically
    num_spikes_all = [num_spikes_all; num_spikes_cur];
end

% group num. spikes from all runs of same event type together
    
% get unique event types for all sessions
unique_ev_type = {};   % initialize array

for item = 1:size(num_spikes_all, 1)   % for each item available
    count = 0;   % initialize count as 0 for current item
    for j = 1:size(unique_ev_type, 1)   % for each unique entry identified
        % if any entry in num_spikes_all exists in uni. array, increment 
        % count by 1
        if isequal(num_spikes_all(item), unique_ev_type(j))
            count = count + 1;
        end
    end
    % if count remains zero at the end of the scan, it means no entry in
    % uni. array agrees with any item in num_spikes_all, add current
    % item to uni. array
    if count == 0
        unique_ev_type = [unique_ev_type; num_spikes_all(item, 1)];
    end
end

num_spikes_comb = {};
for i = 1:length(unique_ev_type)
    num_spikes_comb{i, 1} = min(unique_ev_type{i});
end
% num_spikes_comb = unique_ev_type;

for item = 1:size(unique_ev_type, 1)
    cur_ev_type = unique_ev_type{item};
    spikes_found = {};
    for sess_ind = 1:length(fdnames)   % for each session
        num_spikes_cur_sess = terms.(fdnames{sess_ind}).num_spikes;
        for i = 1:size(num_spikes_cur_sess, 1)
            if isequal(num_spikes_cur_sess{i, 1}, cur_ev_type)
                spikes_found = [spikes_found num_spikes_cur_sess{i, 2}];
            end
        end
    end
    num_spikes_comb{item, 2} = spikes_found;
end

% END (A1): combine number of spikes from all runs together
%--------------------------

% (A2): calculate mean and standard deviation of num. spikes of all runs
% combined

% create array for storing the following,
% col. 1 = event type
% col. 2 = mean of number of spikes in every seg.
% col. 3 = standard dev. of number of spikes in every seg.
% all numeric values are corrected to 3 decimal place
spikes_stats_comb = num_spikes_comb(:, 1);

for item = 1:size(spikes_stats_comb, 1)
    spikes_stats_comb{item, 2} = round(mean(cell2mat(num_spikes_comb{item, 2})), 3);
    spikes_stats_comb{item, 3} = round(std(cell2mat(num_spikes_comb{item, 2})), 3);
end

% END (A2): calculate mean and standard deviation of num. spikes of all runs
% combined
%--------------------------

% (A3): concatenate stats from all runs together on same table

% initialize array with same col. 1 (event type order)
spikes_stats_all = spikes_stats_comb(:, 1);   

for sess_ind = 1:length(fdnames)   % for each run
    ar_read = terms.(fdnames{sess_ind}).spikes_stats;   % read stats array of current run
    for i = 1:size(spikes_stats_all, 1)   % for each row in final array
        for j = 1:size(ar_read, 1)   % for each row in stats array read
            % if event types from both arrays agree, add stats to final
            % array
            if isequal(spikes_stats_all{i, 1}, ar_read{j, 1})
                spikes_stats_all{i, 2+(sess_ind-1)*2} = ar_read{j, 2};   % mean 
                spikes_stats_all{i, 3+(sess_ind-1)*2} = ar_read{j, 3};   % standard dev.
            end
        end
    end
end

% get number of columns established after appending stats from all runs to
% array
ncol = size(spikes_stats_all, 2);

% append stats calcu. based on num. spikes of all runs combined to final
% array
spikes_stats_all(:, ncol+1:ncol+2) = spikes_stats_comb(:, 2:3);

% END (A3): concatenate stats from all runs together on same table
%--------------------------

% (A4): convert array to table

% initialize array to store headers required for table
headers_req = {};
runind = 1;   % initialize run index

% first two col. are event type and channel name
for j = 1:ncol-1   % for every remaining col. 
    if mod(j, 2) == 1   % if col. num. is odd
        headers_req{j} = ['mean_', 'winsize_', num2str(window_size), ...
            '_run_ind_', num2str(runind)];   % construct details of corr. coeff.
    end
    if mod(j, 2) == 0   % if col. num is even
        headers_req{j} = ['std_', 'winsize_', num2str(window_size), ...
            '_run_ind_', num2str(runind)];   % construct details of p-value
        %   once both details about corr. coeff. and p-value are
        %   constructed, increment runind by 1 for next run
        runind = runind + 1;
    end
end
headers_req{ncol-1+1} = ['mean_', num2str(window_size), ...
            '_run_ind_', 'all'];   % construct details of corr. coeff.
headers_req{ncol-1+2} = ['std_', num2str(window_size), ...
            '_run_ind_', 'all'];
        
% convert cell array to table and add table headers
table_spikes_stats_all = cell2table(spikes_stats_all, ...
    'VariableNames',{'event type', headers_req{:}});


% END (A3): concatenate stats from all runs together on same table
%--------------------------

%(A4): save table to path and struct

% format filename for table
filename_table_comb = ['sub', subnum, '_table_spikes_stats_run_all' ...
    '_winsize_', num2str(window_size), '.csv'];
table_comb_path = fullfile(fname_op, filename_table_comb);

% write resultant table to path 
if op_results == 1
    writetable(table_spikes_stats_all, table_comb_path);   % table of clin. det. ch.
end

% store spikes_stats_all array under every fieldname in struct.
for sess_ind = 1:length(fdnames)
    terms.(fdnames{sess_ind}).spikes_stats_all = spikes_stats_all;
end

% update terms struct. to path
if op_results == 1
    save(fullfile(fname_op, filename_op), 'terms', '-v7.3');
end

% END (A4): save table to path and struct
%--------------------------

end   % end if length(fdnames) >= 1
    


%---------------------------------------------------------------------------
% FUNCTION FOR GETTING STATS OF NUMBER OF SPIKES IN EVERY RUN
%---------------------------------------------------------------------------

% FUNCTION OPSTRUCT = GET_SPIKES_STATS(INPUT_ARRAY)
% INPUT_ARRAY contains the following, 
% (i) swra_info: info of swra images
% (ii) event_onsets: onset times (s) of events
% (iii) window_size: window size (s), also equals to the length of segment
% output OPSTRUCT, which contains
% (i) window_size_used
% (ii) ti, initial time (s) of each segment
% (iii) tf, final time (s) of each segment
% (iv) num_spikes, number of spikes in each segment
% (v) spikes_stats, mean and standard dev. of numbers of spikes of all
% segments
% (vi) table_spikes_stats, table listing all stats calculated for every
% event type
function opstruct = get_spikes_stats(input_array)

% %---------------------------------------------------------------------------
% % Prelim: access variables defined in input array
swra_info = input_array.swra_info;   % headers of processed func. images
event_onsets = input_array.event_onsets;   % struct. of event onsets   % subject number of interest
window_size = input_array.window_size;   % current window size in (s)

% initialize output struct. as empty array
opstruct = [];

% get length of time dimension of processed image
nt = swra_info.ImageSize(4);

% check if length of time series is long enough, 256 is used as it's chosen
% as the width of window in welch's method of power spectral density (psd) 
% estimate. If so, change value of com_alff to 1 so that the script will
% calculate ALFF, the relevant corr. coeff., and p-values.
com_alff = 0;
if nt >= 256
    com_alff = 1;
end

% end Prelim: access variables defined in input array

%---------------------------------------------------------------------------
% execute the lines below only if com_alff == 1 (long enough time series)
% if com_alff ~= 1
%     disp('time series is not long enough for pwelch method')
% else
%       
% Part (I): get spike rate in each segment 

tr = swra_info.PixelDimensions(4);   % repetition time, in seconds
nt = swra_info.ImageSize(4);
taxis = (0:nt - 1)*tr;

% create arrays indicating time points of each segment, with
% 50% overlapping btw. neighboring segments
ti_list = 0;   % list of ti (initial time) 
tf_list = window_size;   % list of tf (final time)
while tf_list(end) + window_size/2 < taxis(end)   % while tf < taxis(end)
    ti_list = [ti_list ti_list(end) + window_size/2];   % update lists
    tf_list = [tf_list tf_list(end) + window_size/2];
end

% get number of segments expected to form from time series, 
num_seg = numel(tf_list);

% get arrays of event def and event onsets (in seconds, relative to 
% the start of fmri scan) from structure
event_def = event_onsets.results.event_def;
evti = event_onsets.results.evti;

% initialize array for storing number of spikes in each segment, for each
% type of event. i.e. col. 1 = event type, col. 2 = num. of spikes assoc.
num_spikes = cell(length(event_def), 2);

% for each type of event, loop through each segment in time, then get spike
% rate in that seg. as number of entries that falls into that segment 
for event_ind = 1:numel(evti)   % for each event type
evti_int = evti{event_ind};   % get list of onset times for current event type
    for seg_ind = 1:length(ti_list)   % for each segment in time
        seg_ti = ti_list(seg_ind);   % get ti (initial time) of curr. seg.
        seg_tf = tf_list(seg_ind);   % get tf (final time) of curr. seg.
        % get number of spikes in curr. seg. by counting number of entries
        % in the list of event onsets that falls into time interval of curr.
        % seg.
        num_spikes{event_ind, 1} = min(event_def{event_ind});
        num_spikes{event_ind, 2}{seg_ind} = numel(find(evti_int >= seg_ti & evti_int <= seg_tf));
    end
end

% END Part (I): get spike rate in each segment 
%---------------------------------------------------------------------------

% Part (II): get mean and standard deviation of number of spikes of every
% segment

% create array for storing the following,
% col. 1 = event type
% col. 2 = mean of number of spikes in every seg.
% col. 3 = standard dev. of number of spikes in every seg.
% all numeric values are corrected to 3 decimal place

spikes_stats = num_spikes(:, 1);

for item = 1:size(spikes_stats, 1)
    spikes_stats{item, 2} = round(mean(cell2mat(num_spikes{item, 2})), 3);
    spikes_stats{item, 3} = round(std(cell2mat(num_spikes{item, 2})), 3);
end

% END Part (II): get mean and standard deviation of number of spikes of every
% segment
%---------------------------------------------------------------------------
% Part (III): convert cell array to table

% convert cell array to table and add table headers
table_spikes_stats = cell2table(spikes_stats, ...
    'VariableNames',{'event type', ['mean_winsize', num2str(window_size)], ...
    ['std_winsize_', num2str(window_size)]});

% End Part (III): convert cell array to table
%---------------------------------------------------------------------------

% Part (IV): store quantities calcu. in output struct.

opstruct = struct;

opstruct.window_size_used = window_size;   % current window size (s) 
opstruct.ti_list = ti_list;   % list of initial times  for all segments constructed
opstruct.tf_list = tf_list;   % list of final times  for all segments constructed
opstruct.num_spikes = num_spikes;   % number of spikes in each seg., for each event type
opstruct.spikes_stats = spikes_stats;   % stats of num. of spikes in every seg. 

opstruct.table_spikes_stats = table_spikes_stats;   % table of stats of num. of spikes 

% END Part (X): store quantities calcu. in output struct.
%---------------------------------------------------------------------------



% end   % end if com_alff ~= 1

end   % end function opstruct = get_spikes_stats(input_array)
