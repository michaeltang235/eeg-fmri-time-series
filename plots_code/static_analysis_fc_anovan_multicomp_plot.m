clear all 
close all

% This script intakes 'static_analysis_fc.mat' and perform the following, 
% (1) n-way anova to identify if there are statistically diff. group means, here
% group denotes channel combination (onset-onset, onset-propa, etc., ...)
% (2) multiple comparison tests to identify which group is sig. diff. from
% one another
% (3) using results from mult. comp. tests, make box plot of 95% confidence
% interval of fc of each group (mean +/- 2*standard error)
%---------------------------------------------------------------------------
%---------------------------------------------------------------------------
% BEGIN USER INPUT

tic 

% enter path to directory where input data is stored
input_dir = 'C:\Users\siumichael.tang\Downloads\fmri_project\matrices\static_analysis_fc'; 
% input_dir = '/work/levan_lab/mtang/fmri_project/matrices/static_analysis_fc';

% enter filename of input data
filename_input = 'static_analysis_fc.mat';

% enter path where plots are saved at
% directname_op = '/work/levan_lab/mtang/fmri_project/plots/static_analysis_alff';
directname_op = 'C:\Users\siumichael.tang\Downloads\fmri_project\paper_plots';

% format output filename
filenameg_op = ['static_analysis_fc_boxplot'];

% enter if user wants to write plots to file (1=yes, 0=no)
op_results = 0;

% END USER INPUT
%---------------------------------------------------------------------------
%---------------------------------------------------------------------------

% format path to input .mat file
input_path = fullfile(input_dir, filename_input);

% load input data using path
input_data = load(input_path);

% concatenate fc array of every subject with each together vertically
% note fc_ar has the following format, 
% 1st col. = subject number
% 2nd col. = ied type of reference channel (event type)
% 3rd col. = name of ref. channel
% 4th col. = channel type (ied onset, propagation, or no ied)
% 5th col. = ied type of target channel
% 6th col. = name of target channel
% 7th col. = channel type (ied onset, propagation, or no ied)
% 8th col. = functional connectivity
fc_ar_all = {};   % initialize array fc_ar_all, 

fd_name_sub = fieldnames(input_data.grand);   % obtain fieldnames under grand 
for sub_ind = 1:numel(fd_name_sub)   % for every subject
    fd_name_run = fieldnames(input_data.grand.(fd_name_sub{sub_ind}));   % obtain run fieldnames
    for run_ind = 1:numel(fd_name_run)   % for every run
        fc_ar_all = [fc_ar_all; ...
            input_data.grand.(fd_name_sub{sub_ind}).(fd_name_run{run_ind}).fc_ar];   % concatenate array vertically
    end
end

% obtain fc from rightmost col. in fc_ar_all, and convert them to fisher z
% fc_data_all = cell2mat(fc_ar_all(:, end));
fc_data_all = atanh(cell2mat(fc_ar_all(:, end)));

% use get_ch_comb, defined at end of script, to get channel combination of
% every row in fc_ar_all (onset-onset, onset-propa, onset-noied, etc...)
ch_comb_all = get_ch_comb(fc_ar_all);

% obtain subject number associated with every row in fc_ar_all from col. 1
subject_all = fc_ar_all(:, 1);

% use anovan, (n-way) anova, to determine if there is sig. diff. btw.
% group means, channel combination and subjects
[p1,tbl1,stats1, terms1] = anovan(fc_data_all, {ch_comb_all subject_all}, "Model", "linear", ...
    "random", 2, "Varnames", {'ch_comb', 'subject'}, 'display', 'off');

% use multcompare to get mean and standard error of each group for
% pairwise comparison (which group means are sig. diff. from others)
% see doc. for details
[c,m,h,gnames] = multcompare(stats1);

% format of m is given below, 
% 1st col. = mean estimate of every group
% 2nd col. = standard error of the mean

%-------------
% make plot

% open figure window
% f1 = figure;
% f1 = figure('units','normalized','outerposition',[0 0 1 1]);
f1 = figure('units','normalized','outerposition',[0 0 0.5 1]);

% obtain x data (mean fc of each group) from col. 1 of m, generated by
% multcompare
x_data = m(:, 1);

% format name of every group, concatenate them vertically
g = [{'IED onset-IED onset'}; {'IED onset-IED propa'}; ...
    {'IED onset-IED onset, other'}; {'IED onset-IED propa, other'}; ...
    {'IED onset-no IED'}]; 

% make boxplot showing mean and 95% confidence interval (std error obtained 
% from col. 2 of m) of every group, 
a = boxplot(x_data, g); hold on
e = errorbar(x_data, 2*m(:, 2), 'LineStyle', 'none', 'Color', 'b'); hold on

% set length of cap at end of error bars
e.CapSize = 10;

set(a, 'LineWidth', 1.1);   % set linewidth of boxes
set(e, 'LineWidth', 1.1);   % set linewidth of error bars

% add significant bridges on plot (manually)
% there are 3 sets of groups that are statistically different from each
% other

% enter positions of significant bridge for the 1st set of groups
xl1 = 1;   % x-pos, left 
xr1 = 2;   % x-pos, right
xh1 = 0.78;   % height of bridge
xd1 = 0.01/2;   % drop of bridge on each end

% draw sig. bridge using coordinates specified for 1st set of groups
% line([0.5*(xl1+xr1), 0.5*(xl1+xr1)], [xh1+xd1*2, xh1+xd1*2], 'Color', 'k', 'Marker', '*', 'LineWidth', 0.6); hold on
% line([xl1, xr1], [xh1, xh1], 'Color', 'k', 'LineWidth', 1); hold on   % bridge
% line([xl1, xl1], [xh1-xd1, xh1], 'Color', 'k', 'LineWidth', 1); hold on   % left drop
% line([xr1, xr1], [xh1-xd1, xh1], 'Color', 'k', 'LineWidth', 1); hold on   % right drop

% draw sig. bridges using coordinates specified for 1st set of groups
for i = 0:3   % pair index
hd = 1;   % hori. dist. btw. item
vd = 0.02;   % vert. dist. btw. bridges
line([0.5*(xl1+xr1+hd*i), 0.5*(xl1+xr1+hd*i)], [xh1+xd1*2+vd*i, xh1+xd1*2+vd*i], 'Color', 'k', 'Marker', '*', 'LineWidth', 0.6); hold on
line([xl1, xr1+hd*i], [xh1+vd*i, xh1+vd*i], 'Color', 'k', 'LineWidth', 1); hold on   % bridge
line([xl1, xl1], [xh1-xd1+vd*i, xh1+vd*i], 'Color', 'k', 'LineWidth', 1); hold on   % left drop
line([xr1+hd*i, xr1+hd*i], [xh1-xd1+vd*i, xh1+vd*i], 'Color', 'k', 'LineWidth', 1); hold on   % right drop
end

% enter positions of significant bridge for the 2nd set of groups
xl2 = 2;   % x-pos, left 
xr2 = 3;   % x-pos, right
xh2 = 0.68;   % height of bridge
xd2 = 0.01/2;   % drop of bridge on each end

% draw sig. bridges using coordinates specified for 2nd set of groups
for i = 0:2   % pair index
hd = 1;   % hori. dist. btw. item
vd = 0.02;   % vert. dist. btw. bridges
line([0.5*(xl2+xr2+hd*i), 0.5*(xl2+xr2+hd*i)], [xh2+xd2*2+vd*i, xh2+xd2*2+vd*i], 'Color', 'k', 'Marker', '*', 'LineWidth', 0.6); hold on
line([xl2, xr2+hd*i], [xh2+vd*i, xh2+vd*i], 'Color', 'k', 'LineWidth', 1); hold on   % bridge
line([xl2, xl2], [xh2-xd2+vd*i, xh2+vd*i], 'Color', 'k', 'LineWidth', 1); hold on   % left drop
line([xr2+hd*i, xr2+hd*i], [xh2-xd2+vd*i, xh2+vd*i], 'Color', 'k', 'LineWidth', 1); hold on   % right drop
end

% enter positions of significant bridge for the 3rd set of groups
xl3 = 3;   % x-pos, left 
xr3 = 4;   % x-pos, right
xh3 = 0.58;   % height of bridge
xd3 = 0.01/2;   % drop of bridge on each end

% draw sig. bridges using coordinates specified for 3rd set of groups
for i = 0:1  % pair index
hd = 1;   % hori. dist. btw. item
vd = 0.02;   % vert. dist. btw. bridges
line([0.5*(xl3+xr3+hd*i), 0.5*(xl3+xr3+hd*i)], [xh3+xd3*2+vd*i, xh3+xd3*2+vd*i], 'Color', 'k', 'Marker', '*', 'LineWidth', 0.6); hold on
line([xl3, xr3+hd*i], [xh3+vd*i, xh3+vd*i], 'Color', 'k', 'LineWidth', 1); hold on   % bridge
line([xl3, xl3], [xh3-xd3+vd*i, xh3+vd*i], 'Color', 'k', 'LineWidth', 1); hold on   % left drop
line([xr3+hd*i, xr3+hd*i], [xh3-xd3+vd*i, xh3+vd*i], 'Color', 'k', 'LineWidth', 1); hold on   % right drop
end

hold off

box on 

% get current gca
ax1 = gca;

% set line width of axes
ax1.LineWidth = 0.9;

% set limits of y-axis
ax1.YLim = [0.2 0.9];
ax1.YTick = [ax1.YLim(1):0.1:ax1.YLim(2)];

% set y-label
ylabel('FC','Interpreter','latex');

% set fontsize of axes
% ax1.FontSize = 13;
ax1.XAxis.FontSize = 13;
ax1.YLabel.FontSize = 15;

% obtain axes limits
xmax = ax1.XLim(2);
xmin = ax1.XLim(1);

% set aspect ratio of plot
pbr = 1/1.2;
pbaspect([xmax-xmin, pbr*(xmax-xmin), 1]); % multiple y-axis by the factor

% set properties of ticks
ax1.TickDir = 'out';   % direction of ticks
ax1.YMinorTick = 'on';   % show minor y-ticks
% ax1.TickLength = 2*ax1.TickLength;   % set length of ticks
ax1.TickLength = 2*[ax1.TickLength(1) 4*ax1.TickLength(1)];   % set length of ticks

% ax1.FontName = 'Consolas';

% set tick label interpreter
ax1.TickLabelInterpreter = 'latex';


% output plots to path
if op_results == 1
saveas(f1, fullfile(directname_op, filenameg_op), 'epsc');
saveas(f1, fullfile(directname_op, filenameg_op), 'jpeg');
end

% USER DEFINED FUNCTION:
%---------------------------------------------------------------------------
% this function constructs channel comb (str) based on channel type of ref.
% (col. 4) and target (col. 7) channel for every row of input array
function ch_comb = get_ch_comb(fc_ar)
ch_comb = {};
for i = 1:size(fc_ar, 1)
    if strcmp(fc_ar(i, 4), 'IED onset') && strcmp(fc_ar(i, 7), 'IED onset') ... 
            && isequal(fc_ar(i, 2), fc_ar(i, 5))   % same ied type
        ch_comb{i, 1} = 'IED onset-IED onset';
    end
    if strcmp(fc_ar(i, 4), 'IED onset') && strcmp(fc_ar(i, 7), 'IED propa') ...
            && isequal(fc_ar(i, 2), fc_ar(i, 5))
        ch_comb{i, 1} = 'IED onset-IED propa';
    end
    if strcmp(fc_ar(i, 4), 'IED onset') && strcmp(fc_ar(i, 7), 'IED onset') ... 
            && ~isequal(fc_ar(i, 2), fc_ar(i, 5))   % other ied type
        ch_comb{i, 1} = 'IED onset-IED onset, other';
    end
    if strcmp(fc_ar(i, 4), 'IED onset') && strcmp(fc_ar(i, 7), 'IED propa') ...
            && ~isequal(fc_ar(i, 2), fc_ar(i, 5))
        ch_comb{i, 1} = 'IED onset-IED propa, other';
    end
    if strcmp(fc_ar(i, 4), 'IED onset') && strcmp(fc_ar(i, 7), 'no IED') 
        ch_comb{i, 1} = 'IED onset-no IED';
    end
end

end
