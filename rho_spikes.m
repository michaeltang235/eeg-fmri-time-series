clear all 
close all

tic 
%---------------------------------------------------------------------------
%---------------------------------------------------------------------------
% BEGIN USER INPUT

% enter subject number (str)
subnum = '14';

% enter path to directory where all input files are located
directname = ['/work/levan_lab/mtang/fmri_project/', 'sub', subnum];
% directname = ['C:\Users\siumichael.tang\Downloads\fmri_project\', 'sub', subnum];

% format filenames of processed fmri images, explicit mask, electrode,
% motion parameters
filename_swraimg = ['swra*.nii'];   % processed func. images
filename_expmask = 'wEPI_bet_mask.nii';   % explicit mask
filename_elect =  [subnum, '_*Koordinaten*.xlsx'];   % file containing mni coord. of all electrode pairs
filename_spikes = ['subject', subnum, '_rates.txt'];   % file of spike rates
filename_motion = ['rp_*.txt'];   % motion parameters generated by SPM in the realignment step

% format path at which clinically determined reference channels located
clin_ref_ch_directname = '/work/levan_lab/mtang/fmri_project';   % directory where the file is
clin_ref_ch_filename = 'ref_channel_clin_det.txt';   % filename 

% enter path where ouput struct. is stored at
fname_op = [directname, filesep, 'matrices' filesep 'rho_spikes'];   % direct. of output matrix
filename_op = 'rho_spikes.mat';   % filename of output file

% enter if output should be written to path (1 = yes, 0 = no)
op_results = 1;

% END USER INPUT
%---------------------------------------------------------------------------
%---------------------------------------------------------------------------
%----------------------------------
% locate paths of func. images and their details 

% use get_path function to obtain full path of input files
[~, swra_file_path, ~] = get_path(directname, filename_swraimg);   % swra func. images
[~, expmask_file_path, ~] = get_path(directname, filename_expmask);   % normalized mask images
[~, elect_file_path, ~] = get_path(directname, filename_elect);   % file containing info. about electrodes coordinates
[~, spikes_file_path] = get_path(directname, filename_spikes);   % spike rates
[~, motion_file_path, ~] = get_path(directname, filename_motion);   % motion parameters

 % get full path of file of clinically determined reference channels
clin_ref_ch_file_path = fullfile(clin_ref_ch_directname, clin_ref_ch_filename);  

% createterms structure to store output data calcu. by function defined
% below
terms = struct;

% read input files and use get_rho_spikes function to get required data
for run_ind = 1:numel(swra_file_path)   % for each row in path of processed func. images
    
% run_ind = 1;
% read input files
swra_img = niftiread(swra_file_path{run_ind});   % swra func. images
swra_info = niftiinfo(swra_file_path{run_ind});   % info about this particular swra func. images
expmask = single(niftiread(expmask_file_path{:}));   % convert image data type to single
electar = readcell(elect_file_path{:});   % cell array containing info. about electrodes
spikesar = readcell(spikes_file_path{:});   % cell array containing info. about spike rates

% assemble input array of function, get_rho_spikes 
input_array = struct;   % initialize struct.
input_array.swra_img = swra_img;   % processed func. images
input_array.swra_info = swra_info;   % headers of processed func. images
input_array.expmask = expmask;   % explicit mask
input_array.electar = electar;   % array of electrode coordinates
input_array.spikesar = spikesar;   % array of spike rates
input_array.clin_ref_ch_file_path = clin_ref_ch_file_path;   % path of file of clin. det. channels
input_array.subnum = str2num(subnum);   % subject number in format of integer
input_array.motion_file_path = motion_file_path{run_ind};   % path of motion parameter file

% get indices of current run number embedded in processed image filename
sind = regexp(lower(swra_file_path{run_ind}), 'run');   % start index
eind = regexp(lower(swra_file_path{run_ind}), '.nii');   % end index
sess_num = swra_file_path{run_ind}(sind+3:eind-1);   % get indices of run number

% create fieldname representing current session number
fieldname = sprintf('run%s', sess_num);

% store output calcu. under current fieldname of terms
terms.(fieldname) = get_rho_spikes(input_array);

% access table of current session created by function get_rho_spikes
table_rho_clin_ch = terms.(fieldname).table_rho_clin_ch;   % table of clinically det. channels

% format filenames and full paths of tables
filename_clin_table = ['sub', subnum, '_table_rho_clin_ch_run_', sess_num, '.csv'];
clin_table_path = fullfile(fname_op, filename_clin_table);   % path of table of clin. det. channels

% output tables created in current session
if op_results == 1
    writetable(table_rho_clin_ch, clin_table_path);   % table of clin. det. ch.
end

end   % end for run_ind = 1:numel(swra_file_path)

%---------------------------------------------------------------------------
% output struct. calcu. to path after looping through all sessions 
if op_results == 1
    save(fullfile(fname_op, filename_op), 'terms');
end

%---------------------------------------------------------------------------

toc

%---------------------------------------------------------------------------
%---------------------------------------------------------------------------

% define function get_rho_spikes requiring an input array, which
% has the fields defined below,
% SWRA_IMG is the data of processed image file
% SWRA_INFO is the info (headers) associated with the processed image file
% EXPMASK is the explicit mask image
% ELECTAR is the array containing info. about all electrodes used,
% CLIN_REF_CH_FILE_PATH is the path of the file of clinically determined
% channels,
% SUBNUM is the subject number in integer form
% MOTION_FILE_PATH is the path of motion parameter file
% and outputs,
% OPSTRUCT, a structure that contains info. about coordinates of
% electrdoes, signals within 3X3X3 boxes centered at midpoint between
% electrode pairs, corr. coeff. btw. ref. and target channels, etc 
% see end of function for details of variables included in this struct.

function opstruct = get_rho_spikes(input_array)

% %---------------------------------------------------------------------------
% % Prelim: access variables defined in input array
swra_img = input_array.swra_img;   % processed func. images
swra_info = input_array.swra_info;   % headers of processed func. images
expmask = input_array.expmask;   % explicit mask
electar = input_array.electar;   % array of electrode coordinates
spikesar = input_array.spikesar;   % array of spike rates
clin_ref_ch_file_path = input_array.clin_ref_ch_file_path;   % path of clin. det. channels
subnum = input_array.subnum;   % subject number in format of integer
motion_file_path = input_array.motion_file_path;   % path of motion parameter file

% % end Prelim: access variables defined in input array
% %---------------------------------------------------------------------------
% Part (I): sort electrodes by their types

% use sort_elect to sort electrode array by their types
ele_sorted = sort_elect(electar);

% END PART (I): sorte electrodes by their types
%---------------------------------------------------------------------------
% % Part (II): find midpoint of each pair of electrode contacts in both mni
% and image space

% use get_midpt_elect to locate midpoint of all electrode channels
% col. 1 = name of channel, 
% col. 2 = midpt in mni space, 
% col. 3 = midpt in image space
midpt = get_midpt_elect(ele_sorted, swra_info);

% END Part (II): find midpoint of each pair of electrode contacts in both mni
% and image space
%---------------------------------------------------------------------------

% Part (III): construct 3X3X3 boxes centered at midpoint of each electrode
% pair to store signals enclosed thereof

% % assign essential variables for constructing the transfer function
% % required for chebyshev filter
% window_size = 60;   % in seconds
tr = 1.5;   % repetition time, in seconds

fs = 1/tr; % sampling frequency, in Hz

% use Chebyshev Type 1 bandpass filter to allow freq. compo. btw. 
% [0.01 and 0.1] Hz to pass through, use cheby1 to get 
% transfer function coefficients (normalized freqs. are used)
[b,a] = cheby1(2,0.5,[0.01 0.1]/(fs/2));

% initialize cell array named sig_box to store signals of voxels within
% 3X3X3 boxes, 
% col. 1: name tags of electrode pairs (channel)
% col. 2: motion-filtered signal within the 3X3X3 box of each channel
% col. 3: signal in col. 2 but decomposed into segments
% col. 4: noise-filtered (bandpass) signal of all segments in col. 3
% col. 5: averages of segments in col. 4
sig_box = {};

% use for loop to get signals within each box from processed (swra) func. images
for i = 1:numel(midpt)   % for each electrode type
    for j = 1:size(midpt{i}, 1)   % for each electrode pair under current type
        sig_box{i}{j, 1} = midpt{i}{j, 1};   % get name tag of electrode pair
        mxyz = midpt{i}{j, 3};   % get midpoint in image space
        
        % get signals from swra images, convert from int to double
        signal =  double(swra_img(mxyz(1)-1:mxyz(1)+1, mxyz(2)-1:mxyz(2)+1, ...
            mxyz(3)-1:mxyz(3)+1, :));  
        
        % filter motion artifacts from signal using filter_motion.m
        signal_mo_filt = filter_motion(motion_file_path, signal);
        
        % apply bandpass filter (Chebyshev filter) to remove low-freq. drift 
        % and noises from signal
        signal_noise_filt = signal_mo_filt;   % initialize array
        for x_vox = 1:size(signal_mo_filt, 1)   % for each voxel in x-dir.
            for y_vox = 1:size(signal_mo_filt, 2)   % for each voxel in y-dir.
                for z_vox = 1:size(signal_mo_filt, 3)   % for each voxel in z-dir.
                    % extract signal at voxel interested, squeeze the
                    % array to remove dim. of length 1, then use Chebyshev
                    % filter to remove noises
                    signal_noise_filt(x_vox, y_vox, z_vox, :) = ...
                        filtfilt(b, a, squeeze(signal_mo_filt(x_vox, ...
                        y_vox, z_vox, :))); 
                end
            end
        end
        
        % assign noise-filtered signal to second column of current cell in 
        % sig_box array
        sig_box{i}{j, 2} = signal_noise_filt;
        
        % create regional mask from explicit mask using the coordinates of
        % the 3X3X3 box
        reg_mask = double(expmask(mxyz(1)-1:mxyz(1)+1, mxyz(2)-1:mxyz(2)+1, ...
            mxyz(3)-1:mxyz(3)+1));
        num_nonzero = nnz(reg_mask);   % get number of non-zero entries in regional mask
        
        % get avg. signal within the current box
        avg_signal = zeros(1, size(signal_mo_filt, 4));   % initialize avg. signal array
        for t = 1:size(signal_mo_filt, 4)   % for each time step
            % get sum of singals in box at current time, then get average
            % signal by dividing the sum by number of non-zero entries in
            % in the regional mask
            % could have used mean(nonzeros), but this method is adopted just 
            % in case if the signal is zero but the mask isn't at a voxel
            avg_signal(t) = sum(sum(sum(reg_mask.*(signal_noise_filt(:, :, :, t)))))/num_nonzero;
        end     
        
        % assign avg. signal calculated to col. 3 of cell array
        sig_box{i}{j, 3} = avg_signal;
   
    end
end

% END Part (III): construct 3X3X3 boxes centered at midpoint of each electrode
% pair to store signal enclosed thereof
%---------------------------------------------------------------------------
% Part (IV): group signals of all channels in single layer

% group all electrode types in one single layer of cell array
% col. 1 = id assigned to electrode pair
% col. 2 = name tag of electrode pair
% col. 3 = motion-filtered signals within 3X3X3 box constructued
% col. 4 = signals in col. 3, but decomposed into segments
% col. 5 = signals in col. 4, but noise-filtered (bandpass filter)
% col. 6 = averages of sgements in col. 4
sig_box_all = {};   % initialize sig_box_all array
rownum = 1;   % initialize row number as 1 

for i = 1:numel(sig_box)   % for each electrode type in sig_box
    for j = 1:size(sig_box{i}, 1)   % for each pair of electrode contacts
        sig_box_all(rownum, 1) = {rownum};   % assign row number as id 
        sig_box_all(rownum, 2:2+size(sig_box{i}, 2)-1) = sig_box{i}(j, :);   % assign relevant info.
        rownum = rownum + 1;   % increment row number by 1
    end
end

% END Part (IV): group signals of all channels in single layer
%---------------------------------------------------------------------------
% Part (V): match channels in spike rates array with that of signal box

% use clean_match_spikes to get spikes struct.
spikes = clean_match_spikes(spikesar, sig_box, sig_box_all);

% get spike rates array in single layer with channels matched with sig_box_all
spikes_all = spikes.spikes_all;

% END Part (V): match channels in spike rates array with that of signal box
%---------------------------------------------------------------------------
% Part (VI): get correlation coefficient between electrode channels

% with ids assigned to pairs of electrode contacts, get correlation
% coefficients between each pair, store data in corr_array, with
% col. 1 = id of reference electrode pair, 
% col. 2 = id of target electrode pair, 
% col. 3 = name of reference electrode pair
% col. 4 = name of tagret electrode pair
% col. 5 = pearson's correlation coefficient between ref. and target pairs

% get total number of pairs of ele. contacts
num_contact_pair = size(sig_box_all, 1);

% initialize corr_array 
corr_array = cell(num_contact_pair^2, 5);
row = 1;   % initialize row number as 1

for i = 1:size(sig_box_all, 1)   % for each row in sig_box_all
    for j = 1:size(sig_box_all, 1)   % again, for each row in sig_box_all
        corr_array{row, 1} = sig_box_all{i, 1};   % id of ref. ele. pair
        corr_array{row, 2} = sig_box_all{j, 1};   % id of target ele. pair
        corr_array{row, 3} = sig_box_all{i, 2};   % name of ref. ele. pair
        corr_array{row, 4} = sig_box_all{j, 2};   % name of target ele. pair
        ref_sig = [sig_box_all{i, 4}]';   % ref. signal
        tar_sig = [sig_box_all{j, 4}]';   % target signal
        % corr. coef. btw. ref. and targ. sig.
        corr_array{row, 5} = corr(ref_sig, tar_sig, 'Type', 'Pearson');  
        row = row + 1;   % increment row number by 1
    end
end

% END Part (VI): get correlation coefficient between electrode channels
%---------------------------------------------------------------------------
% Part (VII): grouped corr. coeff. and spike rates by ref. elect. channel

% exclude entries of corr. coeff. btw. 
% the same ref. and targ. electrode (e.g. {1, 1}, {2, 2}, ...)

% get list of ids and channel names
ids_all = cell2mat(sig_box_all(:, 1));

% sort corr. coeff. by electrode channels
cor_ref = {};   % initialize array
for ref_id = 1:length(ids_all)   % for each channel
    cor_ref{ref_id} = {};   % initialize cell for current channel
    for i = 1:size(corr_array, 1)   % for each row in corr_array
        % if id of ref. ch. (col. 1) agrees with current id, 
        % and if id of target ch. (col. 2) isn't the same as ref. ch.
        % assign relevant info. to cell of current ref. channel
        if (corr_array{i, 1} == ids_all(ref_id)) && (corr_array{i, 1} ~= corr_array{i, 2})
            cor_ref{ref_id} = [cor_ref{ref_id}; corr_array(i, :)];   % concatenate current cell
        end
    end
end

% get spike rates for all target elect. under each ref. elect. channel 
% in cor_ref,
% names of channels in both cor_ref and spikes_ref are in the same order
spikes_ref = {};    % initialize array
for ref_id = 1:length(ids_all)   % for each ref. elect. channel
    spikes_ref{ref_id} = {};   % initialize cell for current channel
    for i = 1:size(cor_ref{ref_id}, 1)   % for each row in current channel of cor_ref
        for j = 1:size(spikes_all, 1)   % for each row in spikes_all array
            % compare channel names in the two arrays, if name in current
            % row in cor_ref agrees with that in spikes_all, assign
            % relevant info. to current cell of spikes_ref by vertical
            % concatenation
            if strcmp(cor_ref{ref_id}{i, 4}, spikes_all{j, 2})
                spikes_ref{ref_id} = [spikes_ref{ref_id}; spikes_all(j, :)];  
                break;   % break loop if spike rates are found for current targ. ch.
            end
        end
    end
end

% Part (VII): grouped corr. coeff. and spike rates by ref. elect. channel
%---------------------------------------------------------------------------

% Part (VIII): get correlations between func. conn. and spikes rates of all
% ref. channels

% for each ref. channel, we have obtained the following
% (i) corr. coeff. (pearson's) btw. ref. and target channels (func. conn.)
% (ii) spike rates of all target channels, 
% then get spearman's corr. coeff. (rho_cs_sp) between (i) and (ii)

% get corr. coeff. (spearman's) between corr coeff. btw. channels and spikes rates

% initialize arrays for storing spearman corr. coeff. and their p-values,
% with 1st layer denoting ref. ch. for which the var. interested are calcu.
% and 2nd layer displaying the var. int. in all segments of each ref. ch.
rho_cs_sp = {};   % spearman corr.
pval_cs_sp = {};   % p-value of spearman corr.

% get spearman corr. coeff. and their p-values btw. (i) and (ii)
for ref_id = 1:numel(cor_ref)   % for each ref. channel
    [rho_cs_sp{ref_id}, pval_cs_sp{ref_id}] = corr([cor_ref{ref_id}{:, 5}]', ...
        [spikes_ref{ref_id}{:, 3}]', 'Type', 'Spearman');
end   % end for ref_id = 1:numel(cor_ref)   % for each ref. channel

% END Part (VIII): get correlations between func. conn. and spikes rates of
% all reference channels
%---------------------------------------------------------------------------
% Part (IX): sort f.c. and spike rates of ref. channels into same and other
% types

% for each ref. channel, look for pairs with target
% channels belonging to types other than the ref. 

% get ids ov each electrode type
ids_type = cell(1, numel(sig_box));   % initialize cell array
row_i = 1;   % initialize row_id (initial row number)
for i = 1:numel(sig_box)   % for each type in sig_box
    rowspan = size(sig_box{i}, 1);   % get rowspan of current electrode type
    % get ids of current electrode type
    ids_type{i} = [sig_box_all{row_i:(row_i + rowspan - 1), 1}];   
    row_i = row_i + rowspan;   % adjust row_i for next electrode type
end

% initialize arrays for current ref. channel
spikes_ref_same_type = {};   % spike rates of pairs with targ. of same type
spikes_ref_other_type = {};   % spike rates of pairs with targ. of other types
cor_ref_same_type = {};   % corr. coeff. of pairs with targ. of same type
cor_ref_other_type = {};   % corr. coeff. of pairs with targ. of other types
    
% scan through each ref. channel, look for ids of target channels belonging
% to types other than the ref.
for ref_id = 1:numel(cor_ref)
    
    % initialize row numbers for arrays of same and other types
    row_ind_same_type = 1;   
    row_ind_other_type = 1;

    % get current electrode type of ref_id
    for i = 1:numel(ids_type)   % for each id type
        if ismember(ref_id, ids_type{i})   % if ref_id belongs to the type
            type_ind = i;   % get type of ref_id
        end
    end
    
    % for each pair under the current ref. channel
    for pair_ind = 1:size(cor_ref{ref_id}, 1)
        
        % if id of targ. ch. belongs to the set of ids of current type
        % assign relevant info. to arrays of same type
        if ismember(cor_ref{ref_id}{pair_ind, 2}, ids_type{type_ind})
            cor_ref_same_type{ref_id}(row_ind_same_type, :) = cor_ref{ref_id}(pair_ind, :);
            spikes_ref_same_type{ref_id}(row_ind_same_type, :) = spikes_ref{ref_id}(pair_ind, :);
            % increment row number by 1 for next targ. ch. identified as 
            % same type
            row_ind_same_type = row_ind_same_type + 1;   
        else
            % otherwise, assign info. to arrays of other types
            cor_ref_other_type{ref_id}(row_ind_other_type, :) = cor_ref{ref_id}(pair_ind, :);
            spikes_ref_other_type{ref_id}(row_ind_other_type, :) = spikes_ref{ref_id}(pair_ind, :);
            % increment row number by 1 for next targ. ch. identified as
            % other types
            row_ind_other_type = row_ind_other_type + 1;
        end
    end   % end for pair_ind = 1:size(cor_ref{ref_id}, 1)
    
end   % end for ref_id = 1:numel(cor_ref)

% Part (IX): sort f.c. and spike rates of ref. channels into same and other
% types
%---------------------------------------------------------------------------
% Part (X): get correlation btw. f.c. and spike rates of target channels
% of different types than the ref. 

% for each ref. channel, we have obtained
% (A) functional connectivity (f.c.) btw. the ref. and all targ. channels 
% belonging to types other than the ref. and
% (B) the corresponding spike rates of targ. ch., 
% get spearman's corr. coeff. (rho_cs_sp_ot) btw. (A) and (B), '_ot' is
% added to denote 'other types'

% initialize arrays for storing spearman corr. coeff. and their p-values,
% with 1st layer denoting ref. ch. for which (rho_sp) are calcu.
% and 2nd layer displaying (rho_sp) in all segments of each ref. ch.
rho_cs_sp_ot = {};   % spearman corr. of ch. pairs of other types
pval_cs_sp_ot = {};   % p-value of spearman corr.

% get spearman corr. coeff. and their p-values btw. (i) and (ii)
for ref_id = 1:numel(cor_ref_other_type)   % for each ref. channel
    [rho_cs_sp_ot{ref_id}, pval_cs_sp_ot{ref_id}] = corr([cor_ref_other_type{ref_id}{:, 5}]', ...
        [spikes_ref_other_type{ref_id}{:, 3}]', 'Type', 'Spearman');
end   % end for ref_id = 1:numel(cor_ref)   % for each ref. channel

% end Part (X): get correlation btw. f.c. and spike rates of target channels
% of different types than the ref.
%---------------------------------------------------------------------------
% Part (XI): identify clinically determined reference channels

% use get_clin_ref_ch to get clinically determined ref. channels and their ids 
ch_name_clinical = get_clin_ref_ch(subnum, clin_ref_ch_file_path, sig_box_all);

% Part (XI): identify clinically determined reference channels
%---------------------------------------------------------------------------
% Part (XII): generate tables listing all variables calculated

% initialize array storing var. calcu. for clinically determined ref. ch.
rho_clin_ch_array = {};   

% for each ref. ch., we computed pearson's corr. coeff. btw. the ref. 
% ch. and all other target channels (A), and spike rates of all target 
% channel (B), then we computed spearman's corr. coeff. (C) btw. (A) and (B).
% also, for each ref. ch., we calculated (C) for target ch. belonging to
% types other than the ref. (D)
row_num = 1;   % initialize row number for assigning data to array
for i = 1:length(ch_name_clinical)   % for each type of clin. det. ch.
    for j = 1:size(ch_name_clinical{i}, 1)   % for each ch. in current type
        ref_id = ch_name_clinical{i}{j, 1};   % get id of ref. ch.
        rho_clin_ch_array{row_num, 1} = ref_id;   % assign id to array
        rho_clin_ch_array{row_num, 2} = ch_name_clinical{i}{j, 2};   % assign name to array
        rho_clin_ch_array{row_num, 3} = round(rho_cs_sp{ref_id}, 3);   % spearman's rho
        rho_clin_ch_array{row_num, 4} = round(pval_cs_sp{ref_id}, 3);   % p-value
        rho_clin_ch_array{row_num, 5} = round(rho_cs_sp_ot{ref_id}, 3);   % other type, spearman's rho
        rho_clin_ch_array{row_num, 6} = round(pval_cs_sp_ot{ref_id}, 3);   % other type, p-value
        rho_clin_ch_array{row_num, 7} = round(spikes_all{ref_id, 3}, 3);   % spike rate (per min)
        row_num = row_num + 1;   % increment row number by 1
    end
end

% convert cell array to table and add table headers
table_rho_clin_ch = cell2table(rho_clin_ch_array, ...
    'VariableNames',{'id', 'channel name', 'corr. coeff.', ...
    'p-val.', 'corr. coeff. ot', 'p-val. ot', 'spike rate [/min]'});
        

% Part (XII): generate tables listing all variables calculated
%---------------------------------------------------------------------------
% Part (XIII): store quantities calcu. in output struct.

opstruct = struct;
opstruct.ele_sorted = ele_sorted;   % info. of electrode (sorted by name)
opstruct.midpt = midpt;   % coordinates of midpoint between each pair of electrode contacts 
opstruct.sig_box = sig_box;   % signals within 3X3X3 box centered at each midpoint
opstruct.sig_box_all = sig_box_all;   % signals within 3X3X3 box centered at each midpoint of all channels in single layer
opstruct.spikes_all = spikes_all;   % list of spike rates of all electrode pairs in single layer

opstruct.corr_array = corr_array;   % corr. coeff. (pearson's) btw. channels

opstruct.ids_all = ids_all;   % ids of all channels
opstruct.ids_type = ids_type;   % ids of all channels, sorted by types

opstruct.cor_ref = cor_ref;   % corr. coeff. (pearson's) btw. ref. (1st layer) and targ. (2nd layer) channels
opstruct.spikes_ref = spikes_ref;   % spike rates btw. ref. (1st layer) and targ. (2nd layer) channels

% with corr. coeff. (Y) and spike rates (X) btw. ref. and targ. ch.
% determined,
opstruct.rho_cs_sp = rho_cs_sp;   % spearman's corr. coeff. btw. X and Y
opstruct.pval_cs_sp = pval_cs_sp;   % p-value of spearman's corr. coeff.

% get spearman's corr. coeff. and p-val. for cases when
% target ch. belonging to types other than the ref
opstruct.rho_cs_sp_ot = rho_cs_sp_ot;   % other types, spearman's corr. coeff. btw. X and Y
opstruct.pval_cs_sp_ot = pval_cs_sp_ot;   % other types, p-value of spearman's corr. coeff.

opstruct.ch_name_clinical = ch_name_clinical;   % clin. det. ref. ch.

% store table created above in struct.
opstruct.table_rho_clin_ch = table_rho_clin_ch;   % table of clinically det. channels

% END Part (XIII): store quantities calcu. in output struct.
%---------------------------------------------------------------------------

end   % end function opstruct = get_dynam_rho_spikes(input_array)
